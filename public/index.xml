<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Horribly Underqualified</title>
    <link>https://horriblyunderqualified.com/</link>
    <description>Horribly Underqualified</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 Nov 2019 04:04:51 -0500</lastBuildDate>
    
    <atom:link href="https://horriblyunderqualified.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>We Get It</title>
      <link>https://horriblyunderqualified.com/posts/we-get-it/</link>
      <pubDate>Sat, 09 Nov 2019 04:04:51 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/we-get-it/</guid>
      <description>&lt;p&gt;Spend enough time procrastinating on reddit, you inevitable end up
reading the same links again and again and &lt;em&gt;again&lt;/em&gt;. One of the common
links I see are the ones that complain about JavaScript. There&amp;rsquo;s
&lt;a href=&#34;https://www.destroyallsoftware.com/talks/wat&#34;&gt;wat&lt;/a&gt;, the &lt;a href=&#34;https://medium.com/commitlog/the-internet-is-at-the-mercy-of-a-handful-of-people-73fac4bc5068&#34;&gt;tried and
tired ecosystem
article&lt;/a&gt;
and many many more.&lt;/p&gt;
&lt;p&gt;To all of those articles, I just want to say:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;We get it&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We get it, JavaScript sucks. It&amp;rsquo;s insecure, it has weird features, npm
is out of control, etc. Heard it all. Yep, even that one. Thanks for
your feedback.&lt;/p&gt;
&lt;p&gt;Now what are you gonna do about it? Complaining about valid issues is
great! But ultimately you need to stop complaining and start
fixing. Which is where a lot of these articles stop&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;And oh boy are there a lot of projects working on fixing
JavaScript. For one, you can make TC39 proposals to add new features
to the language. You may say the damage has been done, but I disagree!
Features such as triple equals (===), arrow functions (=&amp;gt;) and
optional chaining (?.) have done a lot to improve the JavaScript
experience. I&amp;rsquo;d go as far as to say that if you don&amp;rsquo;t know ES6+,
you&amp;rsquo;re not really qualified to judge JavaScript. That&amp;rsquo;s like judging
Java pre-generics, or C++ pre-templates or Go, uhh, well you get my
point.&lt;/p&gt;
&lt;p&gt;Another great place to start is contributing to tooling. Whether it&amp;rsquo;s
&lt;a href=&#34;https://github.com/microsoft/typescript&#34;&gt;TypeScript&lt;/a&gt;,
&lt;a href=&#34;https://github.com/npm/cli&#34;&gt;npm&lt;/a&gt; or whatever tools you use, you can
help make the JS ecosystem better. A great innovation that npm just
pushed is automatic dependency screening. That way you can see if your
project has vulnerabilities whenever you run npm.&lt;/p&gt;
&lt;p&gt;Or hell, if you just hate JavaScript, why not work on getting another
language into the browser? With WebAssembly, you can compile a number
of languages to the browser. Go, Rust, C# and many others are already
targeting the browser.&lt;/p&gt;
&lt;p&gt;You&amp;rsquo;re not obligated to help the JS community. But if you&amp;rsquo;re so
passionate that you&amp;rsquo;re screaming from the rooftops about how
JavaScript sucks, maybe spend that effort helping make it suck less.&lt;/p&gt;
&lt;p&gt;However while I will admit that parts of JavaScript truly do suck
(semicolon insertion, automatic globals, etc.), I don&amp;rsquo;t think
JavaScript gets enough credit for the stuff it does get right. For
one, arrow functions are totally awesome! The syntax is concise and
clear, and totally makes me want to strip out all the
fun/func/fn/function keywords in other languages.&lt;/p&gt;
&lt;p&gt;Also package management is pretty nice now! npm installs locally by
default. We have lockfiles and dependency auditing. It&amp;rsquo;s pretty great!
Python&amp;rsquo;s whole pip install is global by default doesn&amp;rsquo;t look as great
anymore&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s also great having a lightweight object/struct type with
destructuring. Almost feels antiquated to have to put quotes around
keys in a Python dict.&lt;/p&gt;
&lt;p&gt;I don&amp;rsquo;t want this to turn into a language bashing session, so I&amp;rsquo;ll end
with this: If you don&amp;rsquo;t like JavaScript in its current state, consider
doing something to change its current state.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;I&amp;rsquo;d like to exclude Gary Bernhardt here because he&amp;rsquo;s awesome and
because that talk was clearly meant in jest. &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Apple &amp; Fashion</title>
      <link>https://horriblyunderqualified.com/posts/apple-and-fashion/</link>
      <pubDate>Sat, 19 Oct 2019 02:11:52 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/apple-and-fashion/</guid>
      <description>&lt;p&gt;Go online and you&amp;rsquo;ll find particularly potent venom directed towards
Apple. Critics denigrate their products as overpriced,
underpowered&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; scams that only uninformed dolts would buy. Others
insist that Apple has become unduly obsessed with aesthetics. They
perpetually raise the question: Do people &lt;em&gt;really&lt;/em&gt; want thinner
phones? Do people &lt;em&gt;really&lt;/em&gt; need a lighter laptop?&lt;/p&gt;
&lt;p&gt;To answer these questions, yes. People do want a thinner phone. They
do want a lighter laptop. Why? Because &lt;strong&gt;fashion&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s talk clothes. Clothes aren&amp;rsquo;t something a lot of nerds think
about. Which is quite weird in my opinion. It&amp;rsquo;s a very easy thing to
think about with a lot of potential upside. But I digress.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s two schools of thought towards clothes: Cargo shorts or no
cargo shorts. This is a vast oversimplification and probable false
dichotomy, but it&amp;rsquo;ll suffice for this post.&lt;/p&gt;
&lt;p&gt;The cargo shorts camp chooses clothes based on utility. Cargo shorts
have plenty of pockets so therefore they are better than normal
shorts. Raincoats keep rain off, so I should always wear a
raincoat. Running shoes are comfortable so I&amp;rsquo;ll wear running shoes.&lt;/p&gt;
&lt;p&gt;The non cargo shorts camp chooses clothes based on, well, not
utility. Most commonly aesthetics, or in the parlance of Tan France,
fuckability. These pants show off my ass. This shirt&amp;rsquo;s color looks
great in the sun. These sunglasses accentuate my face.&lt;/p&gt;
&lt;p&gt;Both camps have valid points. Looking good is a very valid pursuit for
a person, but always with a healthy dose of pragmatism. High heels?
Great. Stilettos on concrete? Maybe not. Very nice Burberry trench
coat? Wonderful. On a hike? Nope. Wearing stretchy pants because
they&amp;rsquo;re comfy? Sure. Wearing sweatpants all the time? Ehhh.&lt;/p&gt;
&lt;p&gt;But what both camps should probably agree on is that one should not
criticize a fashion company for making clothes that are aesthetically
pleasing but not maximally practical.&lt;/p&gt;
&lt;p&gt;So why do people critique Apple for producing devices that are
aesthetically pleasing but perhaps not maximally practical? Why do
they complain that Apple focuses so much on aesthetics?&lt;/p&gt;
&lt;p&gt;And oh man are other companies firmly entrenched on the cargo shorts
side. It&amp;rsquo;s baffling to me how ugly, how cheap-looking, how &lt;em&gt;bad&lt;/em&gt; non
Mac compulers look. How ThinkPads use that eternal dorky grey
plastic. How the Microsoft Surface Book can&amp;rsquo;t be opened without
awkwardly anchoring the bottom half. How most laptops &lt;em&gt;still&lt;/em&gt; have
those inane stickers reminding us that we&amp;rsquo;re using an Intel
processor. How even the most aesthetically pleasing of laptops just do
a poor imitation of a Mac.&lt;/p&gt;
&lt;p&gt;But Nicholas, you say, clothes&amp;rsquo; specs are far less important than that
of a computer. Fine. Then let&amp;rsquo;s take cars as our example.  Cars do
have specs. They have mileage, seat count, max speed, etc. Would you
ever criticize a car company for making a car that just maaaybe
doesn&amp;rsquo;t have the best mileage or maybe not the best engine, but looks
fantastic? Probably not. You&amp;rsquo;d be criticizing the entire American auto
industry.&lt;/p&gt;
&lt;p&gt;People do not need maximally efficient cars. They do not need
maximally efficient computers. Most people drive their car to
work. Most people use their computer to check their email and watch
YouTube. Complaining that people are buying nice looking cars when
they could be buying a cheaper, uglier car that you can use to drag
race is completely missing the point, especially when you&amp;rsquo;re talking
to people who do not and will never drag race in their life.&lt;/p&gt;
&lt;p&gt;Of course with clothes and cars and computers, the product must
ultimately be usable. I don&amp;rsquo;t begrudge any criticisms towards Apple
about malfunctioning computers or buggy software. Nobody should accept
broken products.&lt;/p&gt;
&lt;p&gt;One last kvetch, why do people assume Apple just doesn&amp;rsquo;t know what
they&amp;rsquo;re doing?  Like, it&amp;rsquo;s one thing to guess a company isn&amp;rsquo;t running
optimally. It&amp;rsquo;s a complete other thing to assume they&amp;rsquo;re profoundly
stupid. Like whenever Apple shaves some inches off the iPhone or makes
the screen slightly bigger, or whatever, people always comment
questioning why they made it thinner or why the screen is larger or
whatever. Why? Well probably because they tested it on people, and
people liked the thinner phone. Contrary to Apple promotional
materials, Jony Ive doesn&amp;rsquo;t just sit in a while void dictating the
next iPhone, chamfered edges and all.&lt;/p&gt;
&lt;p&gt;Apple is far from a perfect company. But criticizing it for
prioritizing aesthetics over functionality is like complaining that
Balenciaga sells shorts that aren&amp;rsquo;t cargo shorts.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Y&amp;rsquo;know, this is commonly repeated but I actually believe it&amp;rsquo;s
quite overexaggerated. Perhaps back in the day this was more true,
but Apple computers are quite impressive in some regards such as
SSD speed. Try finding a computer with an equivalent chassis,
processor and SSD for cheaper. It&amp;rsquo;s not easy. &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>People Suck at Email</title>
      <link>https://horriblyunderqualified.com/posts/people-suck-at-email/</link>
      <pubDate>Sat, 05 Oct 2019 01:28:57 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/people-suck-at-email/</guid>
      <description>&lt;p&gt;Just because someone has not responded to an email in a few days
doesn&amp;rsquo;t mean they&amp;rsquo;re angry at you. It doesn&amp;rsquo;t mean they don&amp;rsquo;t like
you. It doesn&amp;rsquo;t mean they want to stop talking to you. They most
likely forgot.&lt;/p&gt;
&lt;p&gt;Expect to send at least a couple follow up emails. If the person you
are emailing is famous or important or a leader of some sorts, expect
to send even more emails. They have a lot on your mind and your email
can slip through the cracks.&lt;/p&gt;
&lt;p&gt;In general assume forgetfulness or laziness before malice.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Surviving CSO</title>
      <link>https://horriblyunderqualified.com/posts/surviving-cso/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:38 -0700</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/surviving-cso/</guid>
      <description>&lt;p&gt;Computer Systems Organization, or CSO, is the third class in NYU CAS&amp;rsquo;s
computer science program. I&amp;rsquo;ve noticed that a lot of people have
trouble in CSO. This is for good reasons. The class covers a lot of
ground, from the C language to systems architecture to
concurrency. This is especially tricky because students face a massive
paradigm shift from the relatively high level bubble of Python and
Java with its managed memory and forgiving error messages, to the raw,
bare metal of C and x86 assembly. It&amp;rsquo;s kind of like going from driving
a 2019 Mercedes to a Model T.&lt;/p&gt;
&lt;p&gt;I was lucky enough to come into the class with some C experience. I&amp;rsquo;ve
also learned some more useful techniques for systems development after
I took CSO. I hope that by writing up a quick guide for preparing and
surviving CSO, future students can be more prepared, get better grades
and be happier people. Well, at least the first two. The last one
might require &lt;a href=&#34;https://www.youtube.com/watch?v=TbwlC2B-BIg&#34;&gt;incremental lifestyle changes sustained over
time&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This guide is applicable whether you have an entire summer to prepare,
a few weeks to practice or even if you&amp;rsquo;re in the middle of the course
and struggling.&lt;/p&gt;
&lt;p&gt;Quick aside, if you&amp;rsquo;re in CSO already and worried that you&amp;rsquo;re going to
fail, don&amp;rsquo;t panic. You are almost certainly not the only person in
this situation. In fact, there&amp;rsquo;s a decent chance a lot of people are
in the same boat. CSO generally has a reasonable curve to it. Not that
you should rely on the curve to pass. Now let&amp;rsquo;s get to work:&lt;/p&gt;
&lt;h2 id=&#34;tooling&#34;&gt;Tooling&lt;/h2&gt;
&lt;p&gt;Memorize these 3 flags: &lt;code&gt;-Wall -Wpedantic -Wextra&lt;/code&gt;. Flags are ways of
modifying your compiler and how it views your code. Like how you can
flip a switch on some cars and go into sports mode. These three flags
basically turn up your compiler&amp;rsquo;s standards for code quality. The
compiler will now warn you about potential issues in your code.&lt;/p&gt;
&lt;p&gt;One side effect is that when you run your code, you may get a gigantic
boatload of errors. &lt;strong&gt;That&amp;rsquo;s fine&lt;/strong&gt;. The compiler is your friend,
who&amp;rsquo;s warning you about potential issues in your code. Better the
compiler than the professor&amp;rsquo;s test suite.&lt;/p&gt;
&lt;p&gt;You can either manually call the compiler with these flags. That means
entering something like &lt;code&gt;gcc -Wall -Wpedantic -Wextra main.c&lt;/code&gt; into the
command line. Or you can &lt;a href=&#34;http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/&#34;&gt;add it to your
Makefile&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Install &lt;a href=&#34;http://www.valgrind.org/&#34;&gt;valgrind&lt;/a&gt;. It&amp;rsquo;s extremely
useful for finding places where your code is messing up memory
management. Consider running your code with it automatically.&lt;/p&gt;
&lt;p&gt;Finally, learn to use the terminal if you haven&amp;rsquo;t already. If you&amp;rsquo;re
using Windows, either install a Linux VM, dual boot Linux or use the
subsystem. Usually your TA has you set up a Linux VM to run your
code. That&amp;rsquo;s perfectly fine, although personally I run the VM headless
and &lt;a href=&#34;https://stackoverflow.com/questions/5906441/how-to-ssh-to-a-virtualbox-guest-externally-through-a-host&#34;&gt;SSH into
it&lt;/a&gt;. That
way I don&amp;rsquo;t have to interact with the VM except via
Terminal. Seriously consider learning git. Version control allows you
to save various versions of your code, making it easier to store and
roll back your code changes. Maybe learn some vim or emacs, personally
I use emacs.&lt;/p&gt;
&lt;p&gt;You don&amp;rsquo;t have to set up all of these things immediately. I&amp;rsquo;d get the
basics down, learn some C, then tinker with your setup more. Don&amp;rsquo;t
feel like you have to get everything perfect immediately.&lt;/p&gt;
&lt;h2 id=&#34;c&#34;&gt;C&lt;/h2&gt;
&lt;p&gt;Find yourself a good source to learn or relearn C. I&amp;rsquo;m not up to date
on the best books for C. Personally I used The C Programming Language
by Kernighan &amp;amp; Ritchie but they teach a very old fashioned style with
terrible variable names (like atoi) and really optimistic uses of
memory. I&amp;rsquo;d look at &lt;a href=&#34;https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list&#34;&gt;some lists
online&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The areas you need to be solid in are pointers and memory layout. C is
very tricky in that its model of memory has very little
abstraction. Languages like Java or Python abstract away pointers with
the idea of references. C has no such concept. The most important fact
you need to keep in mind when writing C is that &lt;strong&gt;everything is a
value&lt;/strong&gt;. Pointers? They&amp;rsquo;re just values that happen to store locations
in memory. Arrays? They&amp;rsquo;re just a pointer to a place in memory (well,
kinda). The &lt;code&gt;a[i]&lt;/code&gt; syntax? That&amp;rsquo;s just syntactic sugar for &lt;code&gt;*(a + i)&lt;/code&gt;
Strings? They&amp;rsquo;re just arrays of characters. So if you add 1 to a
pointer, you are simply changing the value of the pointer, not where
it&amp;rsquo;s pointing.&lt;/p&gt;
&lt;p&gt;Debugging in C is very different due to how C handles (or doesn&amp;rsquo;t
handle) errors. Java will generally spit out nice stack traces which
you can just follow to find your problems. In C, the most common error
you&amp;rsquo;ll get is a segfault. Segfaults do NOT give stack traces and they
basically immediately halt the program. The way I debug segfaults
personally is to print out markers at various parts in my code, then
see which markers get printed before my code segfaults. For instance,
if you have&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;printf(&amp;quot;1\n&amp;quot;);
char* x = NULL;
printf(&amp;quot;2\n&amp;quot;);
*x = 5;
printf(&amp;quot;3\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It&amp;rsquo;s totally okay if you don&amp;rsquo;t understand this. Come back to it once
you&amp;rsquo;ve learned some C. In most cases this will print out:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2   
Segmentation fault: 11
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will allow me to say &amp;ldquo;huh, I guess my error is in between 2 and
3&amp;rdquo;. In fact, you can kinda &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_algorithm&#34;&gt;binary
search&lt;/a&gt; your
code by putting one marker in the middle of your code, then if it gets
printed out, putting a new marker between the old one and the end of
your code, otherwise putting a new marker between the beginning of
your code and the old marker, etc.&lt;/p&gt;
&lt;p&gt;However contrary to popular belief, segfaults are not the worst errors
in C. The worst errors in C are the &lt;em&gt;silent&lt;/em&gt; ones. These are errors
that don&amp;rsquo;t manifest until you happen to run a particular input or
until a particular thread wins. The only way to really ensure that
your code works 100% is to test it yourself. Now, entire books have
been written on proper, thorough testing. But a quick gist is to
always test for bad input. Passing in a pointer? Make it NULL, 0, -1,
anything you want. Giving in integers? What if they&amp;rsquo;re really large?
What if they&amp;rsquo;re negative? Write code that runs through these
situations.&lt;/p&gt;
&lt;p&gt;Under no circumstances should you &lt;strong&gt;ever&lt;/strong&gt; submit code that you have
not compiled and run. Never assume your code will work. Test and
verify.&lt;/p&gt;
&lt;h2 id=&#34;assembly&#34;&gt;Assembly&lt;/h2&gt;
&lt;p&gt;Assembly is probably my weakest area, so I can&amp;rsquo;t offer too much
advice. I guess if I had to give some, it&amp;rsquo;d be that assembly is just
another language. You can run it, you can generate it, etc. A good way
to read assembly is to write some C, compile it with the &lt;code&gt;-S&lt;/code&gt; flag and
look at the assembly. The &lt;a href=&#34;https://godbolt.org/&#34;&gt;Godbolt compiler
explorer&lt;/a&gt; is a nice interactive tool for this as
well.&lt;/p&gt;
&lt;h2 id=&#34;misc&#34;&gt;Misc&lt;/h2&gt;
&lt;p&gt;Start the labs early. I definitely had to use some grace days to
submit some of my labs. Even if just the thought of the labs stresses
you out, just try to take the smallest peek at the problem
statement. Even if it&amp;rsquo;s just looking at the README and jotting down a
couple notes, that&amp;rsquo;ll go a long long way.&lt;/p&gt;
&lt;p&gt;Depending on your professor and their views on collaboration, you
might want to work with a partner. Even if your professor doesn&amp;rsquo;t look
kindly on collaborating on code, you can still talk to each other
about techniques and ideas.&lt;/p&gt;
&lt;p&gt;All the standard advice for hard courses applies. Talk to your
professor. Go to tutoring. Go to office hours. Find a study buddy.&lt;/p&gt;
&lt;p&gt;Buy a print copy of the textbook. Yeah, it&amp;rsquo;s likely you won&amp;rsquo;t read it,
but it&amp;rsquo;s even less likely that you&amp;rsquo;d read the PDF version. You can&amp;rsquo;t
flip through a PDF and print books don&amp;rsquo;t have Facebook or Reddit on
them to distract you. A good trick is to find international editions
of the book. I usually try to find the Indian version, as it&amp;rsquo;s
significantly cheaper (under 20 dollars) and the same exact material.&lt;/p&gt;
&lt;p&gt;This is extremely optional and not recommended unless you have the
free time, but I&amp;rsquo;d consider learning a little Rust. Rust is a very
interesting systems language that enforces a lot of rules about memory
at compile time. It&amp;rsquo;s kind of like working with an extremely anal
programmer who forces you to follow the rules with memory. If you can
pick up some Rust, I guarantee you&amp;rsquo;ll get better at thinking about
memory and how to manage it. Plus it&amp;rsquo;s just a fun language.&lt;/p&gt;
&lt;p&gt;Congratulate yourself: you&amp;rsquo;ve read this advice and are now on the path
to passing CSO! Good luck!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Assuming Stupidity</title>
      <link>https://horriblyunderqualified.com/posts/assuming-stupidity/</link>
      <pubDate>Fri, 26 Jul 2019 16:45:05 -0700</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/assuming-stupidity/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ve all heard of the term mansplaining&amp;mdash;when a man condescendingly
explains something to a person, often female, who already knows
it. It&amp;rsquo;s quite terrible and unfortunately too common on tech.&lt;/p&gt;
&lt;p&gt;While I don&amp;rsquo;t want to discredit the phenomenon of
mansplaining, what I&amp;rsquo;ve noticed is that this situation of a person
assuming another person&amp;rsquo;s stupidity and using it to condescend or
treat them badly is far more common than just the cases of
mansplaining. Especially in tech.&lt;/p&gt;
&lt;p&gt;This condescension and rudeness stems from an assumption of
stupidity. These assumers (or &amp;ldquo;asses&amp;rdquo; for short) often cite times
where they assumed the opposite, namely that a person was competent,
and paid the resulting price for it. Maybe a junior developer wrote
some awful code that crashed the server. Maybe somebody deleted a prod
database. &amp;ldquo;I just can&amp;rsquo;t trust people&amp;rdquo; they claim.&lt;/p&gt;
&lt;p&gt;However the opposite of assuming competence is not to assume
stupidity. The opposite of assuming competence is to be
skeptical. However not a rude, aggressive skepticism, but a friendly,
polite, but thorough skepticism.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s give some examples.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Hey, how do I write to prod?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assuming Alex&lt;/strong&gt; Oh no no no, &lt;strong&gt;never&lt;/strong&gt; write to prod. That&amp;rsquo;s a
&lt;em&gt;terrible&lt;/em&gt; idea.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Okay, well I need to run my code on a server. What should I
do?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assuming Alex&lt;/strong&gt; You&amp;rsquo;ll need to work on the staging environment. For
that, you&amp;rsquo;ll need SSH keys, which you&amp;rsquo;ll need to generate using your
terminal. You can open your&amp;mdash;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; &amp;mdash;oh yeah I&amp;rsquo;ve used ter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assuming Alex&lt;/strong&gt; &amp;mdash;terminal by going to Applications and double
clicking on Terminal. Then you&amp;rsquo;ll need to generate your keys&amp;mdash;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Uh huh, I already did that. &lt;!-- raw HTML omitted --&gt;I&amp;rsquo;ve sshing into servers since I was 15&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assuming Alex&lt;/strong&gt; SSH is how we connect to servers. You can write commands on SSH like &lt;code&gt;ls&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; &amp;hellip; &lt;!-- raw HTML omitted --&gt; Buddy I wrote a terminal in class &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;&lt;em&gt;15 minutes of condescending explaining later&lt;/em&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assuming Alex&lt;/strong&gt; And that&amp;rsquo;s how you SSH into a terminal&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Great&amp;hellip;.&lt;!-- raw HTML omitted --&gt; Damn that took forever. Not talking to him again&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s a few mistakes here. The first is when Alex responds to the
junior dev&amp;rsquo;s request to write to prod with horror. Sure, it&amp;rsquo;s not a great
idea, but acting in such a dramatic fashion just makes the junior dev feel
stupid. The second mistake Alex makes is &lt;em&gt;not asking any
questions&lt;/em&gt;. Alex is spitting out information without any context on
the junior dev&amp;rsquo;s knowledge or the project&amp;rsquo;s current state. Not only is
this advice given from a place of ignorance, as we can see from the
junior dev&amp;rsquo;s attempts at interjections, it&amp;rsquo;s knowledge the junior dev already
has.&lt;/p&gt;
&lt;p&gt;What would a healthier conversation look like? Let&amp;rsquo;s give it a try.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Hey, how do I write to prod?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Skeptical Sarah&lt;/strong&gt; Hmm, why do you want to write to prod?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Oh well I can&amp;rsquo;t process this data locally because it&amp;rsquo;s too
big.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Skeptical Sarah&lt;/strong&gt; Ah, that makes sense. How about we work on the
staging environment instead. Are you familiar with staging
environments?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Yeah, sure&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Skeptical Sarah&lt;/strong&gt; Just to double check, could you give me a quick
explanation of them?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Hmm, well, erm, they&amp;rsquo;re environments that stage stuff?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Skeptical Sarah&lt;/strong&gt; Close! They&amp;rsquo;re environments that mirror prod as
closely as possible which allow us to test code meticulously before we
deploy for real.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junior Dev&lt;/strong&gt; Huh, okay. Thanks for that!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SS&lt;/strong&gt; Now to connect to the staging server, you&amp;rsquo;ll need
SSH keys. Are you familiar with SSH?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JD&lt;/strong&gt; Yep! I&amp;rsquo;ve had to SSH into servers for class.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SS&lt;/strong&gt; Great! Could you send me your public key? If you need help with
that, feel free to ping me again.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JD&lt;/strong&gt; Sounds good!&lt;/p&gt;
&lt;p&gt;With this conversation, Sarah manages to dissect why the junior dev wants
to write to prod, offer a solution and most importantly &lt;em&gt;do it without
being a jerk&lt;/em&gt;. When Sarah senses that the junior dev doesn&amp;rsquo;t know
something, she doesn&amp;rsquo;t just vomit out info, but instead nudges the
junior dev towards the right path.&lt;/p&gt;
&lt;p&gt;Some may argue that the junior dev may not actually know how SSH keys work
and mess up, maybe send Sarah their private key. Sure, but messing up
is part of the process. It&amp;rsquo;s not the end of the world if Sarah ends up
with the junior dev&amp;rsquo;s private key, but the junior dev learns a valuable lesson
in the process. Also, because Sarah was nice and approachable, the
junior dev is much more likely to approach her again and ask for help if
they get stuck on their SSH keys.&lt;/p&gt;
&lt;p&gt;Why does this matter? For one it&amp;rsquo;s always good to not be a jerk. But
also assuming stupidity makes people less likely to ask you
questions. They&amp;rsquo;ll see you as a person who at best wastes their time
with lengthy explanations and at worst is mean to them. And lack of
communication creates the precise problems that an assumption of
stupidity seeks to prevent in the first place. Stupidity also obscures
the true root cause of a potential issue. When Alex assumed the junior
dev was just stupid for asking for prod access, he missed a
potentially crucial bit of information by not asking why the junior
dev wanted prod access. Perhaps the junior dev has a valid
reason. Perhaps there&amp;rsquo;s an underlying issue that needs to be
fixed. Maybe, upon hearing that the junior dev was having trouble
processing the data locally, Alex could have advised a better
alternative, like smaller batches of data. But by assuming stupidity,
Alex was unable to discover the root cause of the intern&amp;rsquo;s problem.&lt;/p&gt;
&lt;p&gt;TL;DR: Being an asshole to get a point across is an inherently
contradictory idea; the act of being an asshole inherently hampers
communication.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Stop Using So Many Damn Ternaries</title>
      <link>https://horriblyunderqualified.com/posts/stop-using-so-many-ternaries/</link>
      <pubDate>Fri, 05 Jul 2019 00:57:47 -0700</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/stop-using-so-many-ternaries/</guid>
      <description>&lt;p&gt;A ternary operator, for those of you who don&amp;rsquo;t know, is an operator
with three parts&amp;mdash;hence ternary operator instead of binary
operator. They look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  cond ? a : b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;code&gt;cond&lt;/code&gt; is true, then the expression evaluates to &lt;code&gt;a&lt;/code&gt;, otherwise it
evaluates to &lt;code&gt;b&lt;/code&gt;. They&amp;rsquo;re very useful in some situations, such as when
you want to conditionally assign to a variable.&lt;/p&gt;
&lt;p&gt;Contrast this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a;
if (cond) {
  a = foo();
} else {
  b = bar();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const a = cond ? foo() : bar();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that we can now use &lt;code&gt;const&lt;/code&gt;, as a is never reassigned. Always a
nice benefit.&lt;/p&gt;
&lt;p&gt;Despite these benefits, ternaries have become rather overused,
especially in the React world. This is partially due the fact that JSX
only allows expressions, which precludes JavaScript&amp;rsquo;s traditional
imperative if statements from being used. Multitudes of developers,
seeing that if statements don&amp;rsquo;t work inside JSX, simply substitute a
ternary operator for the if statement. This is not good.&lt;/p&gt;
&lt;p&gt;First there&amp;rsquo;s the case where you can use a better tool. For instance,
if you need to render something conditionally, say you have &lt;code&gt;Sidebar&lt;/code&gt;
and an &lt;code&gt;isSidebarVisible&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Some people will write the following&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{isSidebarVisible ? &amp;lt;Sidebar /&amp;gt; : null}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While this is nice and declarative, it&amp;rsquo;s also redundant. This works
just fine.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{isSidebarVisible &amp;amp;&amp;amp; &amp;lt;Sidebar /&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Second there&amp;rsquo;s the cases where one can substitute an if statement
quite easily.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div className={classes.App}&amp;gt;
{isUserLoggedIn
 ? isAdmin
 ? &amp;lt;AdminPage /&amp;gt;
 : &amp;lt;UserPage /&amp;gt;
 : &amp;lt;LoginPage /&amp;gt;}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Becomes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (isUserLoggedIn) {
  if (isAdmin) {
   return (
     &amp;lt;div className={classes.App}&amp;gt;
       &amp;lt;AdminPage /&amp;gt;
     &amp;lt;/div&amp;gt;
   );
  }
  return (
    &amp;lt;div className={classes.App}&amp;gt;
      &amp;lt;UserPage /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}
return (
  &amp;lt;div className={classes.App}&amp;gt;
	&amp;lt;LoginPage /&amp;gt;
  &amp;lt;/div&amp;gt;W
); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Yes, yes, the wrapper div is being repeated. If it truly behooves you,
the inner component can be assigned to a variable. A lot of people
forget (or don&amp;rsquo;t know) that JSX is just syntactic sugar for function
calls.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let innerComponent;
if (isUserLoggedIn) {
  if (isAdmin) {
    innerComponent = &amp;lt;AdminPage /&amp;gt;
  } else {
    innerComponent = &amp;lt;UserPage /&amp;gt;
} else {
  innerComponent = &amp;lt;LoginPage /&amp;gt;
}

return &amp;lt;div className={classes.App}&amp;gt; {innerComponent} &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One may ask why ternaries are so terrible. After all, the &amp;ldquo;better&amp;rdquo;
code is a lot more verbose, while the ternary code has a nice
compactness to it.&lt;/p&gt;
&lt;p&gt;Ternaries aren&amp;rsquo;t necessarily bad, but they can easily grow out of hand.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ isUserLoggedIn 
  ? isAdmin
  ? &amp;lt;AdminPage /&amp;gt;
  : isUserVerified
  ? &amp;lt;UserPage /&amp;gt;
  : &amp;lt;VerificationPage /&amp;gt;
  : &amp;lt;LoginPage /&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Fun question, try evaluating this for &lt;code&gt;true, false, true&lt;/code&gt;. This is
hard to read for a few reasons. It&amp;rsquo;s hard to figure out the evaluation
flow. It&amp;rsquo;s hard to figure out which condition goes with what
branch. Finally and most importantly, the states are implicit.&lt;/p&gt;
&lt;p&gt;Control flow is inherently about dealing with different states in your
code. If something is in state A, execute this code. If something is
in state B, execute this code. If statements, returns, etc. are all
tools to map states to code. What if we made this state explicit?&lt;/p&gt;
&lt;p&gt;In this example, we&amp;rsquo;re conditioning on user state. In &lt;em&gt;ahem&lt;/em&gt; more
civilized languages, we could simply make an enum/discriminated union
type and pattern match on it.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum UserState {
  LoggedOut,
  Admin,
  Unverified,
  Verified
}

match user_state {
  UserState::LoggedOut =&amp;gt; LoginPage,
  UserState::Admin =&amp;gt; AdminPage,
  UserState::Verified =&amp;gt; UserPage,
  UserState::Unverified =&amp;gt; VerificationPage
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But if we&amp;rsquo;re using a language that doesn&amp;rsquo;t have pattern matching, we
have to be a little smarter. For instance, we could use string
literals in JavaScript with an object.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const USER_STATES = {
  LOGGED_OUT: &amp;quot;USER_STATES_LOGGED_OUT&amp;quot;,
  ADMIN: &amp;quot;USER_STATES_ADMIN&amp;quot;,
  VERIFIED: &amp;quot;USER_STATES_VERIFIED&amp;quot;, 
  UNVERIFIED: &amp;quot;USER_STATES_UNVERIFIED&amp;quot;
};

const userStates = {
 [USER_STATES.LOGGED_OUT]: &amp;lt;LoginPage /&amp;gt;;
 [USER_STATES.ADMIN]: &amp;lt;AdminPage /&amp;gt;;
 [USER_STATES.VERIFIED]: &amp;lt;UserPage /&amp;gt;;
 [USER_STATES.UNVERIFIED]: &amp;lt;VerificationPage /&amp;gt;;
}

&amp;lt;div className={classes.App}&amp;gt; { userStates[myUserState] } &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Granted, we need to figure out how to compute the userState. And for
that, you&amp;rsquo;ll need to use some if statements. But once we calculate
this state, we can store it in a central location, either context or
Redux, and use the same pattern of an object literal whenever we need
to condition on userState.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const secretPages = {
 [USER_STATES.LOGGED_OUT]: &amp;lt;LoginPage /&amp;gt;;
 [USER_STATES.ADMIN]: &amp;lt;SuperSecretPage /&amp;gt;;
 [USER_STATES.VERIFIED]: &amp;lt;KindaSecretPage /&amp;gt;;
 [USER_STATES.UNVERIFIED]: &amp;lt;NotSecretPage /&amp;gt;;
}

&amp;lt;div className={classes.SecretPage}&amp;gt; {secretPages[myUserState]} &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What&amp;rsquo;s nice about this approach is that it puts the states up
front. When we condition on userState, we&amp;rsquo;re now encouraged to handle
all the cases (in languages with actual enums/pattern matching this
would be forced at compile time). And by emphasizing states, we&amp;rsquo;ve
exposed the underlying data structure: a state machine. Which brings
Rob Pike&amp;rsquo;s quote on data structures vs algorithms to mind.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Data dominates. If you&amp;rsquo;ve chosen the right data structures and
organized things well, the algorithms will almost always be
self-evident. Data structures, not algorithms, are central to
programming.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a complicated algorithm with a lot of boolean logic such as &lt;code&gt;if (a || b &amp;amp;&amp;amp; c)&lt;/code&gt;, consider refactoring it into a series of reasonings
about state. Then you won&amp;rsquo;t need to trace through the program flow:
it&amp;rsquo;ll be obvious.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Endurance Traveling</title>
      <link>https://horriblyunderqualified.com/posts/endurance-traveling/</link>
      <pubDate>Sun, 26 May 2019 20:20:14 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/endurance-traveling/</guid>
      <description>&lt;p&gt;When I started solo traveling a couple years ago, I became obsessed
with techwear. Techwear is clothing that is &amp;ldquo;optimized&amp;rdquo; in some
fashion. It uses fabrics that dry faster, breathe better, offer more
stretch, more durability, etc. The brand that I became enamored with
was &lt;a href=&#34;https://outlier.nyc&#34;&gt;Outlier&lt;/a&gt;. They offer Merino wool t-shirts
that could be worn for days on end, shorts that can be used as
swimming trunks, specialty button ups that are lighter than
linen.&lt;/p&gt;
&lt;p&gt;However, as I went on my first solo trip, I made a few
observations. First, the clothing was not life-changing-ly,
earth-shattering-ly better than my normal, pedestrian cotton shirts
and cotton chinos. Oh sure, I &lt;em&gt;could&lt;/em&gt; wear the shirts for 4 days on
end. But did I want to? And sure, I could hand wash the pants and have
them dry quickly, but I could also just spin dry
them. Newsflash&amp;mdash;washers and dryers exist in 95% of the
world. Second, the clothing felt, well&amp;hellip;wrong. Not that it was
uncomfortable. Far from it, the clothing was extremely
comfortable. But it just wasn&amp;rsquo;t what I wore at home. And while Outlier
puts a lot of effort into making the clothing look normal and not
tech-y, the clothing felt less a fashionable garment and more an
expensive, kinda dorky gadget.&lt;/p&gt;
&lt;p&gt;When I made it back home, I took an inordinate amount of pleasure in
wearing my normal, impractical clothing. A cotton oxford shirt and a
pair of black chinos may not breathe as well, may not resist smells
and stains as easily, but they were normal to me.&lt;/p&gt;
&lt;p&gt;I was certainly not alone in this pursuit of optimization. Techwear is
only a small subset of the traveling &amp;ldquo;hacks&amp;rdquo; that are peddled around
the internet. People discuss the optimal places to go, using the
optimal flight scheme and stopping at the optimal restaurants to
eat. These optimizations are often quite useful; nobody should pay 600
dollars for a flight from New York to Paris. But at the same time,
this optimization obsession lends an intensity, a certain level of
stress to traveling that is not necessary.&lt;/p&gt;
&lt;p&gt;For an example of this stress, simply go to a tourist heavy city; New
York, Paris, Rome, etc. and look for a nuclear family, often American,
rushing from attraction to attraction. The parents are attempting to
stick to their strict timeline, sweating and stressing in the
process. The children are tired and hungry, bored and confused at
their panicking parents.&lt;/p&gt;
&lt;p&gt;Why does this optimization cause so much stress and misery? Because
the family is &lt;strong&gt;outside their baseline&lt;/strong&gt;. They are sleeping in an
unfamiliar place, eating unfamiliar food and demanding a far stricter
schedule than they would ever consider at home. Now, for the short
burst trips that Americans love, the weekend dashes in Paris or the
week long European frenzy, this is perfectly fine. But past a few days
and this system breaks down.&lt;/p&gt;
&lt;p&gt;In programming, there&amp;rsquo;s a commonly cited quote from Donald Knuth that
&amp;ldquo;premature optimization is the root of all evil&amp;rdquo;. These tricks of
techware clothing, packed schedules and tourguide obsessions are the
premature optimizations of traveling.&lt;/p&gt;
&lt;p&gt;What&amp;rsquo;s the alternative? For this, we need to look far down under to
Australia and New Zealand. Aussies and Kiwis travel for extremely long
periods of time. A short trip for an Australian is maybe a month
long. In basically every hostel I&amp;rsquo;ve stayed in, there&amp;rsquo;s been an Aussie
or a Kiwi cooking. At first, I thought this was just out of frugality,
and partially it is. But I recently realized that cooking allows
them to eat something closer to home, bringing them back to their
baseline. It&amp;rsquo;s comforting and sustaining at the same time.&lt;/p&gt;
&lt;p&gt;Basically, to lessen stress while traveling, do what you like to do at
home. For each of us, this is different. For instance, I don&amp;rsquo;t
particularly like sightseeing as much as eating and wandering. So I
don&amp;rsquo;t try to force myself into sightseeing just because I&amp;rsquo;m
traveling. If you don&amp;rsquo;t like eating too much different food, eat food
from home. If you want to bring a piece of clothing that isn&amp;rsquo;t super
practical, but makes you feel at home, go for it&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;! There&amp;rsquo;s no way
to &amp;ldquo;win&amp;rdquo; traveling. And if someone tries to judge your trip because
you didn&amp;rsquo;t see site X or do activity Y, well fuck them. It&amp;rsquo;s your trip.&lt;/p&gt;
&lt;h2 id=&#34;a-quick-coda-on-backpacks&#34;&gt;A Quick Coda on Backpacks&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;m very skeptical of the gigantic backpack that swings around like an
oversized hump slamming into the poor people who veer into the
wearer&amp;rsquo;s path. For a very niche, very specific trip, those backpacks
are useful, say offroading in the jungles of Thailand. But if you&amp;rsquo;re
doing a Interrail trip through Europe with the occasional bus, y&amp;rsquo;know
what&amp;rsquo;s super handy?  Wheels. I&amp;rsquo;ve spent far too much time sweating
with a heavy fucking bag weighing me down, desperately trying to find
the train station. A suitcase with wheels, while less &amp;ldquo;ooh look at me
I&amp;rsquo;m an adventurer&amp;rdquo;, is much more maneuverable and ergonomic.&lt;/p&gt;
&lt;p&gt;Huge backpacks are the perfect example of premature optimization in
traveling. Unless you&amp;rsquo;re doing a trip that requires going to
destinations without roads&amp;mdash;mind you, not lack of paved roads, but
lack of &lt;em&gt;roads&lt;/em&gt; in general&amp;mdash;then a suitcase will work just fine.&lt;/p&gt;
&lt;p&gt;Honestly I suspect the backpacks are more for the self image of a
brave adventurer, literally &amp;ldquo;backpacking&amp;rdquo; around the world. Great for
Instagram, less great for your back.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Within reason of course &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>What Do You Want (Instead)?</title>
      <link>https://horriblyunderqualified.com/posts/what-do-you-want/</link>
      <pubDate>Tue, 26 Feb 2019 17:33:26 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/what-do-you-want/</guid>
      <description>&lt;p&gt;A lot of virtual ink has been spilled about dependency hell and
left-pad and how NPM is hell incarnate. Medium posts moan about how
NPM is insecure, is full of bad packages and is emblematic of
developers&amp;rsquo; laziness. They&amp;rsquo;re not wrong. However, when one raises an
issue with a service, there is always the inevitable follow up: what
do you want instead? There&amp;rsquo;s no clear answer to this question for
package management. Do we want to go to the bad old days of adding
script tags and polluting our global namespace? Do we want to switch
to large catch-all libraries a la Boost or jQuery? What do you want?&lt;/p&gt;
&lt;p&gt;One common answer to this question is to point to other package
distributions that appear to not have these problems. Take your pick
between Bundler, Cargo, Composer, Pip, etc. Except, there&amp;rsquo;s a few
flaws with this. First, these registries and respective package
managers have their own problems. Pip has the inane global
installation by default and non determinism. Cargo is beginning to
have the same problems as NPM in dependency size, especially
compounded by Rust&amp;rsquo;s compile times. I love Rust, but downloading and
compiling packages can take a bit. Second, there&amp;rsquo;s the issue of
scale. While it is nice to compare to other languages, NPM is a little
unique in the sheer size of the ecosystem. Due to several factors
which quite frankly I don&amp;rsquo;t feel like explaining (fragmentation,
churn, diversity of usage), the ecosystem has the perfect storm of
repetition and scale. Granted, Python is also rather diverse in its
usages, but ask anybody who has had to install Tensorflow and they&amp;rsquo;ll
tell you Python dependency management needs work as well.&lt;/p&gt;
&lt;p&gt;Which brings me to my main point: the problems of NPM are problems
that every package manager either faces or will face. I.e. NPM is not
unique. The reason NPM gets all the coverage is because it&amp;rsquo;s reached
these problems faster than any other ecosystem. But the fundamental
problems of massive dependencies; tiny, yet powerful packages and
massive attack surfaces will be problems that everybody will need to
address.&lt;/p&gt;
&lt;p&gt;Why? Well first, because packages &lt;strong&gt;work&lt;/strong&gt; dammit. They&amp;rsquo;re an
effective way of reusing software at a much more granular level than
the massive swiss army knife libraries of yore. Try to find a newish
language that isn&amp;rsquo;t moving to the package model. Even Go, the grumpy
grampa yelling &amp;ldquo;get off my lawn&amp;rdquo; of 21st century languages, is moving
to packages. This isn&amp;rsquo;t surprising at all. When we design our own
projects, do we rely on monolithic objects that provide all the
functions we need? No, we split them up into granular, modular
abstractions.&lt;/p&gt;
&lt;p&gt;Now, there&amp;rsquo;s always the straw man argument of &amp;ldquo;what about the is-odd
package??&amp;rdquo; Well of &lt;em&gt;course&lt;/em&gt; we shouldn&amp;rsquo;t make packages for checking
the parity of a number. That shouldn&amp;rsquo;t have to be said. But there&amp;rsquo;s a
lot of useful cases in between is-odd and jQuery in which packages
solve a real problem.&lt;/p&gt;
&lt;p&gt;The next point that people often make is, why not write the code
yourself? And sure, in the trivial cases that&amp;rsquo;s true. You can write a
decent set of array/string/object primitives instead of using
lodash. You can write a delay Promise function yourself. But people
don&amp;rsquo;t just avoid writing code due to laziness. They avoid it because
of &lt;em&gt;specialization&lt;/em&gt;. A commonly used package will probably have less
bugs (cf &lt;a href=&#34;https://en.wikipedia.org/wiki/Linus&#39;s_Law&#34;&gt;Linus&amp;rsquo; Law&lt;/a&gt;), be
faster than the naive implementation, and handle more cases. Not to
mention, they&amp;rsquo;ll get bugfixes for free. I can&amp;rsquo;t count the number of
times I&amp;rsquo;ve fixed a bug by bumping a version number.&lt;/p&gt;
&lt;p&gt;Another interesting point people make is that the reason behind NPM&amp;rsquo;s
issues is JavaScript&amp;rsquo;s lack of standard library. I don&amp;rsquo;t disregard
this completely, there&amp;rsquo;s probably some amount of packages (&lt;em&gt;cough&lt;/em&gt;
Lodash &lt;em&gt;cough&lt;/em&gt;) which depend on JS&amp;rsquo;s poor standard library. But if you
look at the most depended upon packages, beside Lodash most of the
packages wouldn&amp;rsquo;t fall under a standard library. Request, chalk,
react, express, commander, or moment don&amp;rsquo;t really appear to be
standard library material (okay maybe moment/request, but Rust for
instance does not provide either functionality in its stdlib).&lt;/p&gt;
&lt;p&gt;And besides, large standard libraries don&amp;rsquo;t exactly seem great
either. They&amp;rsquo;re tied to the release cycle of the language, meaning if
there&amp;rsquo;s a bug in the standard library, or worse, a security hole, you
need to beg and plead users to upgrade their language. Meanwhile, a
package means that even if a user doesn&amp;rsquo;t upgrade their existing
projects, future projects will automatically use the newer
package. And tools like NPM and GitHub are starting to warn people
automatically about their dependency security holes.&lt;/p&gt;
&lt;p&gt;Besides, as Python is finding out, if you bundle certain things in
your standard library, but newer, better alternatives come out, you&amp;rsquo;re
going to be stuck with a bunch of outdated packages in your standard
library. Imagine if jQuery was JavaScript&amp;rsquo;s standard library. Hell,
for the longest time it basically was.&lt;/p&gt;
&lt;p&gt;This isn&amp;rsquo;t to say packages are perfect or that we should just ignore
the issues with packages. I&amp;rsquo;m just sick of people hating on NPM as if
there&amp;rsquo;s something unique about it that makes it bad and I&amp;rsquo;m sick of
people hating on packages without proposing a better option. If you
want to go back to script tags and globals be my guest. I&amp;rsquo;ll be here
with my million pound node_modules.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mirror Shining</title>
      <link>https://horriblyunderqualified.com/posts/mirror-shining/</link>
      <pubDate>Sat, 01 Dec 2018 15:55:20 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/mirror-shining/</guid>
      <description>&lt;p&gt;One of my earliest programming projects was for my Intro to Computer
Science class in high school. The assignment was to create a game in
NetLogo. NetLogo, for those who are not familiar, is a program where
users can control &amp;ldquo;turtles&amp;rdquo; and &amp;ldquo;patches&amp;rdquo;, basically agents and the
squares they move on. Users can move the turtles, which can in turn
paint the patches they traverse.&lt;/p&gt;
&lt;p&gt;I decided to make a simple platformer with a twist&amp;mdash;the map was to be
encased in darkness except for a bubble of light. I started this
project early, having been bitten by a previous project that I may
have started the day before it was due. I remember getting the core
functionality down, such as the basic jumping physics (literally just
up and to the right/left, I didn&amp;rsquo;t want to program actual physics);
the bubble of light that slowly expanded; level loading, etc. However,
after I finished the core functionality, I didn&amp;rsquo;t stop.  I implemented
shooting projectiles and basic enemies. I added trapdoors that dropped
the player into deadly lava when stepped upon. I wanted users to be
amazed at all the functionality this game had. None of these features
were essential or required. I simply wanted to build them anyways.&lt;/p&gt;
&lt;p&gt;I didn&amp;rsquo;t know it then, but what I was doing was not
unusual. Programmers by nature like to improve their code. Whether
that&amp;rsquo;s adding features or refactoring or adding scalability, we love
to constantly improve our projects. I like to call this habit &amp;ldquo;mirror
shining&amp;rdquo;. Much as some people love to obsess about giving their shoes
a mirror shine, programmers love to obsess about their code.&lt;/p&gt;
&lt;p&gt;Now, this is the usual section in the blog post structure where I&amp;rsquo;m
supposed to make a point for how mirror shining is bad and how we
should all stop doing it. But that&amp;rsquo;s not true. Mirror shining is
perfectly fine. Compared to a similar term, &amp;ldquo;bikeshedding&amp;rdquo;, mirror
shining isn&amp;rsquo;t wasting time on useless details. Instead, it&amp;rsquo;s dealing
with fundamental, often crucial points, such as improving user
experience or refactoring messy code, or scalability. It&amp;rsquo;s about going
beyond what is merely required and building a product that is truly
admirable.&lt;/p&gt;
&lt;p&gt;However, it&amp;rsquo;s important to recognize when mirror shining is advisable
and when it is not. For instance, a web application that will be
continually used and maintained is a perfect case for mirror
shining. All the little details and finishing touches will play a
factor in maintenance, usability and overall customer
satisfaction. But if a company gives a 2 day take home project for a
job application? Maybe a multithreaded async S C A L A B L E webserver
isn&amp;rsquo;t needed. Maybe a custom responsive UI with extra fancy animations
is a little much.&lt;/p&gt;
&lt;p&gt;Having said that, would I still have put as much work into my project?
Certainly. After all, God is in the details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create Your Own Reality</title>
      <link>https://horriblyunderqualified.com/posts/create-your-own-reality/</link>
      <pubDate>Sun, 28 Oct 2018 23:59:07 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/create-your-own-reality/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been thinking about closures recently. Closures are really
neat. And they&amp;rsquo;re not particularly hard to understand, at least at a
summary level. But they&amp;rsquo;re often misunderstood because it&amp;rsquo;s hard to
understand &lt;em&gt;why&lt;/em&gt; they&amp;rsquo;re so powerful and why they&amp;rsquo;re so useful. For
that, you need context. So let&amp;rsquo;s get into some Γ&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;!&lt;/p&gt;
&lt;p&gt;Closures stem from a simple problem: How do I hide information, while
still providing some form of access to it? Languages like C have two
ways of allocating data: stack allocation and heap allocation. Stack
allocation is very simple: you call a function, it allocates a
predetermined amount of space (called a frame), and once the function
is done being called, you automatically roll back up the stack and
deallocate the memory. What&amp;rsquo;s nice about stack allocation is that it&amp;rsquo;s
very hard to mess up. You can&amp;rsquo;t forget to free memory, you can&amp;rsquo;t
access it once it&amp;rsquo;s been called. Most importantly, when you call into
a library, you know what&amp;rsquo;s going to happen: stack frame gets
allocated, stuff happens, stack gets rolled back up. The issue comes
with sharing data that A. you don&amp;rsquo;t know the size of at compile time,
and B. persists beyond a function call. For this, you need heap
allocation.&lt;/p&gt;
&lt;p&gt;Heap allocation is a little messier. You manually call some sort of
allocater, in C stdlib it&amp;rsquo;s called &lt;code&gt;malloc&lt;/code&gt;, with a requested amount of
memory, then when you&amp;rsquo;re done, you manually call free and it frees the
memory. The issue comes when you have a library or some unknown code
that operates on the heap. Namely, you don&amp;rsquo;t know what&amp;rsquo;s going to
happen! For all you know, the library could overwrite the memory. Or
it could free it. Or just mess it up in some way. You can think of it
as sending your memory into big, mysterious monolith that may or may
not destroy it.&lt;/p&gt;
&lt;p&gt;So what&amp;rsquo;s a smart developer like yourself to do? You create what&amp;rsquo;s
called a closure. A closure stems from a simple idea: functions are
values. This may seem a little weird, depending on the languages
you&amp;rsquo;ve used. Nonetheless, bear with me. The first corollary to this
simple idea is that functions can be returned from functions&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Again, a
little odd. But what&amp;rsquo;s the big deal here? Well let&amp;rsquo;s take a look at
this piece of code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() {
  var a = 10;
  return function() {
    console.log(a);
  }
}
var fn = foo();
fn();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What does this print? There&amp;rsquo;s two (somewhat) reasonable options:
&lt;code&gt;undefined&lt;/code&gt; (I&amp;rsquo;d also accept NullPointerException or an &amp;ldquo;a is
undefined&amp;rdquo; error), or &lt;code&gt;10&lt;/code&gt;. The first one is tempting, especially
according to the rules of stack allocation. After all, once &lt;code&gt;foo&lt;/code&gt; has
been called, the stack should be rolled up and the variables
deallocated. Even if we assign the function that &lt;code&gt;foo&lt;/code&gt; returns to a
new variable, the function is trying to call a variable that no longer
exists. And if this were true, we&amp;rsquo;d basically have function-values
that are very much like C function pointers&amp;mdash;basically just variable
GOTOs. But what if we choose the other option? What if we break the
rules here&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. What if we change our reality?&lt;/p&gt;
&lt;p&gt;The answer here is you get an innovation. You get something that
changes programming forever. Seem overdramatic? Sure, but it&amp;rsquo;s also
true. The first big deal is information hiding.&lt;/p&gt;
&lt;p&gt;Imagine we have a dictionary that associates names to birthdays:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var birthdays = {
	&amp;quot;Alexei&amp;quot;: &amp;quot;12 August 1904&amp;quot;,
	&amp;quot;Olga&amp;quot;: &amp;quot;15 November 1895&amp;quot;,
	&amp;quot;Anastasia&amp;quot;: &amp;quot;18 June 1901&amp;quot;,
	&amp;quot;Nicholas&amp;quot;: &amp;quot;18 May 1868&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now imagine we pass it to a function &lt;code&gt;mysteriousMonolith&lt;/code&gt; that we
don&amp;rsquo;t know. This could be a library function or code written by
coworkers or even &lt;em&gt;gasp&lt;/em&gt; code you copied from StackOverflow.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Nobody knows what goes on in there...
mysteriousMonolith(birthdays);

// Could print the birthdays, nothing, 
// or something completely different.
console.log(birthdays)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For all we know, the dictionary could have been eaten by the aliens
inside the monolith. Or it could be turned into a gigantic space baby&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Not ideal. Well, with closures we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function createBirthdayLookup(birthdays) {
	return function(name) {
		birthdays[name];
	}
}


var lookup = createBirthdayLookup(birthdays);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, instead of passing our precious dictionary of birthdays to the
mysterious monolith, we can pass a function.&lt;/p&gt;
&lt;p&gt;Now, we can sleep easy by simply passing a closure:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysteriousMonolith(lookup)
// Guaranteed to print the same as before
console.log(birthdays);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But this is only the beginning. The second big deal is where it gets
really good.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function createPerson(name, age, height) {
	
	function getName() {
	  return name;
	}
	
	function getHeight() {
	  return height;
	}
	
	function getAge() {
	  return age;
	}
	
	return function(msg) {
	  switch(msg) {
		  case &amp;quot;getName&amp;quot;:
			  return getName();
			  break;
		  case &amp;quot;getHeight&amp;quot;:
			  return getHeight();
			  break;
		  case &amp;quot;getAge&amp;quot;:
			  return getAge();
			  break;
	  }
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This may seem familiar&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;. Indeed, we can think of this function,
&lt;code&gt;createPerson&lt;/code&gt;, as creating an object! Now you&amp;rsquo;re probably wondering,
&amp;ldquo;This can&amp;rsquo;t be an object! Where&amp;rsquo;s the class? Where&amp;rsquo;s the
inheritance?&amp;quot;. And sure, in modern day programming, object oriented
programming is expected to follow certain idioms. Objects are
instantiated using classes, which are usually signified by a nice
&lt;code&gt;class&lt;/code&gt; keyword. The class is expected to inherit from a different
class, etc, etc. But at its core, object oriented programming doesn&amp;rsquo;t
have to have inheritance or fancy keywords. At their core, objects are
simply closures that respond to messages. And besides, your class?
Just a plain ol&amp;rsquo; function called &lt;code&gt;createPerson&lt;/code&gt;.&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;The really really cool part about this is that closures aren&amp;rsquo;t
something built into the computer. They&amp;rsquo;re not some physical law or
some reaction discovered. They were an idea that people
invented. People decided to break the laws of the stack. Except&amp;hellip;the
laws of the stack aren&amp;rsquo;t built into the computer either. In fact, the
computer has no idea about all of these mumblings about stack and heap
and their differences. To the computer, memory is just a big array. A
really really big array, but that&amp;rsquo;s about it.&lt;/p&gt;
&lt;p&gt;So who does know about these ideas? The language! Whether it&amp;rsquo;s a
compiler, an interpreter or a compiler-interpreter, whatever
implements the underlying language is the one to know all of these
concepts and translate them into machine speak.&lt;/p&gt;
&lt;p&gt;And that&amp;rsquo;s what&amp;rsquo;s so damn cool about language design. In the end,
&lt;strong&gt;you&amp;rsquo;re creating your own reality.&lt;/strong&gt;&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; Want a world where closures
exist? Build it. Want a world where memory safety is guaranteed? Go
ahead and build it. Want a world where variables are hoisted and
&lt;code&gt;this&lt;/code&gt; behaves exactly the opposite of what you&amp;rsquo;d expect? Sure thing
Mr. Eich! Go right ahead and build it.&lt;/p&gt;
&lt;p&gt;So maybe the next time you have a problem that you&amp;rsquo;re struggling to solve,
don&amp;rsquo;t just think about how to solve it. Think about how to change your
reality.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Lame type theory joke. Please ignore. &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;A second corollary is that functions don&amp;rsquo;t necessarily have to
have names. This isn&amp;rsquo;t as important. &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;An interesting question to ask is what happens when you break
these rules? &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=AXS8P0HksQo&amp;amp;t=1s&#34;&gt;https://www.youtube.com/watch?v=AXS8P0HksQo&amp;amp;t=1s&lt;/a&gt; &lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Yeah yeah, I know, there are more idiomatic ways of doing this, but I
wanted to be explicit. &lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Fun exercise to the reader: add inheritance to closure-based
classes. I don&amp;rsquo;t quite know how to do this either, so I&amp;rsquo;m
interested to see what people do! &lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Not to mention, this is a pretty badass way of solving your
problems. Got a problem? Make a reality where it doesn&amp;rsquo;t
exist. How very Thanos of you. &lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>Free Startup Ideas</title>
      <link>https://horriblyunderqualified.com/posts/free-startup-ideas/</link>
      <pubDate>Wed, 05 Sep 2018 21:19:00 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/free-startup-ideas/</guid>
      <description>&lt;p&gt;Free Startup Ideas. Success not guaranteed&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Printing: Make a better printer. Make ink cheap and printers
reliable. Make the UI easy and connecting simple.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;College Chooser: Help kids find the right college. Help them wade
through the marketing and bullshit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Benchmarking: Benchmark people&amp;rsquo;s products for them and help
determine optimizations. Basically Google Pagespeed but for
everything.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Google Summer of Code 2018: Ruby</title>
      <link>https://horriblyunderqualified.com/posts/gsoc-ruby-2018/</link>
      <pubDate>Tue, 14 Aug 2018 15:06:22 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/gsoc-ruby-2018/</guid>
      <description>&lt;p&gt;My Google Summer of Code project for Ruby is coming to an end. In a
nutshell, the project was to add type annotations to Ruby. When I
first approached this problem, my thoughts were &amp;ldquo;this is just a
syntatical change, this shouldn&amp;rsquo;t be hard&amp;rdquo;. Haha, yeah, that wasn&amp;rsquo;t
quite true. While I did end up adding type annotations, I didn&amp;rsquo;t
manage to complete all of my goals, and the ones that I did complete,
I did by the skin of my teeth. Why couldn&amp;rsquo;t I complete my goals? What
happened? Was I simply too lazy? Well yes, but wait, there&amp;rsquo;s more!&lt;/p&gt;
&lt;p&gt;When I first started the project, I had never seen the Ruby codebase
before. Frankly, I didn&amp;rsquo;t really think I was going to get accepted to
GSoC, as the precise feature I proposed had already been &lt;a href=&#34;https://bugs.ruby-lang.org/issues/9999&#34;&gt;rejected by
Matz&lt;/a&gt;. But to my surprise, I
was accepted into the program, for which I am endlessly grateful to my
mentor &lt;a href=&#34;https://tonyarcieri.com/&#34;&gt;Tony Arcieri&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So when GSoC started, I forked the repo, cloned it, and immediately
attempted to understand the parser. The Ruby parser is a LALR parser
generated by Bison contained in a single file &lt;code&gt;parse.y&lt;/code&gt; that numbers
over 11k lines. For context, the only file larger than &lt;code&gt;parse.y&lt;/code&gt; that
are actual source code files (not counting JIT headers, configure
files or libraries) is &lt;code&gt;io.c&lt;/code&gt; at 13,270 lines.&lt;/p&gt;
&lt;p&gt;Anyways, I began reading &lt;code&gt;parse.y&lt;/code&gt; and attempting to understand
it. The first mistake I made was attempting to understand the entire
file. With a codebase of this size, basically any function call or
macro will lead you down a rabbit hole. I remember trying to trace the
YYMALLOC calls, which lead to having to understand various structs
with other nested structs, and having to understand how Ruby
implements its own heap, and other various minutae. I attempted to do
this for a bit. What didn&amp;rsquo;t help was that since &lt;code&gt;parse.y&lt;/code&gt; is not
strictly speaking a C file, all of my navigation tools like ggtags
didn&amp;rsquo;t work.&lt;/p&gt;
&lt;p&gt;In the meanwhile, I also taught myself the basics of Bison. I already
knew some stuff about parsing from &lt;a href=&#34;http://www.craftinginterpreters.com/&#34;&gt;Crafting
Interpreters&lt;/a&gt; and had written
some simple recursive descent parsers before. Therefore, Bison wasn&amp;rsquo;t
too much of a reach. I will say that Bison&amp;rsquo;s overall documentation
isn&amp;rsquo;t fantastic. Often times when I learn a new tool, I read a couple
different tutorials. That way a topic that I may have found confusing
in one tutorial will be reinforced by a different tutorial. Plus, if I
get bored with one tutorial I can always switch to a different
one. For Bison, first there&amp;rsquo;s a real dearth of tutorials. Sure,
there&amp;rsquo;s a lot of slides and theoretical documents on Bison, but
there&amp;rsquo;s not a lot of hands on, real world information.&lt;/p&gt;
&lt;p&gt;Thus, I ended up using the &lt;a href=&#34;https://www.gnu.org/software/bison/manual/bison.html&#34;&gt;Bison
manual&lt;/a&gt; a lot,
which was pretty informative. However, even the most complicated
example in the Bison manual was essentially a fancy
calculator. Compared to the complex beast that is the Ruby grammar,
that&amp;rsquo;s not exactly equivalent.&lt;/p&gt;
&lt;p&gt;Sidenote, I&amp;rsquo;ve noticed a severe lack of hands on, cookbook style books
or tutorials on programming language topics (other than Crafting
Interpreters). A book that would cover topics like &amp;ldquo;here&amp;rsquo;s how to make
a package manager&amp;rdquo; or &amp;ldquo;how to write a simple typechecker&amp;rdquo; would be
extremely valuable. I get that books like the Dragon book are great
and all, but I really don&amp;rsquo;t want to read 100 pages on parsing theory
just to get to the point where I can write a simple parser.&lt;/p&gt;
&lt;p&gt;Anyways, armed with some basic Bison knowledge, I decided to dive into
&lt;code&gt;parse.y&lt;/code&gt; again. My mentor, Tony, gave me some nice resources,
including &lt;a href=&#34;https://github.com/whitequark/parser&#34;&gt;a parser&lt;/a&gt; written by
whitequark. In addition, whitequark helped translate a chapter from
the Ruby Hacking Guide, a book in Japanese about the Ruby source
code. This chapter covered the Ruby lexer, which, not gonna lie, is
pretty insane. Essentially, the lexer requires a lot of context
specific information, such as whether the lexer is lexing a function
name, whether it&amp;rsquo;s at the beginning of an expression, etc. The way
that this is done is through a finite state machine. The parser sets
the lexer state at various grammar rules. Depending on the lexer
state, you&amp;rsquo;ll get different tokens or even errors, so this is pretty
important. I&amp;rsquo;ll return to this for&amp;hellip;reasons.&lt;/p&gt;
&lt;p&gt;With all of this info, I started to take &lt;a href=&#34;https://github.com/NicholasLYang/gsoc-2018-ruby-types&#34;&gt;some
notes&lt;/a&gt; on the
parser. While I didn&amp;rsquo;t end up getting too far with the notes, this was
pretty useful to organize my thoughts. Eventually, I figured out
enough about the grammar to add a new option to &lt;code&gt;f_norm_arg&lt;/code&gt;,
essentially the rule for a normal argument (Ruby has a few different
kinds of arguments, such as keyword args and default args). Tony and I
had decided in a colon to delimit types. Interestingly enough, Ruby
doesn&amp;rsquo;t have a tCOLON token. Instead, the Bison file just uses a
literal &amp;lsquo;:&#39;. While that&amp;rsquo;s fine for the ternary operator (the only case
where it&amp;rsquo;s used), we wanted an explicit token for the type rule. I
added a tCOLON token, which was pretty easy, since the lexer code
outside of the states is pretty simple.&lt;/p&gt;
&lt;p&gt;I also noticed some interesting decisions with the grammar rules. For
instance, Ruby does not have a function declaration grammar
rule. Instead, it is grouped along with a bunch of other rules in a
gigantic primary rule. This means that changing function grammar rules
can be kind of tricky.&lt;/p&gt;
&lt;p&gt;However, it was after implementing argument type signatures where I
got stuck. You see, adding the annotations to the parser was only the
first part of the project. The second, and arguably more important
part was to add output to Ripper, Ruby&amp;rsquo;s parser library. After all,
these annotations are meaningless unless a third party can utilize
them. Ripper provides this third party access. It allows Ruby
developers to parse Ruby code into an s-expression form. And from the
outside, adding the type annotations to Ruby should be rather simple,
no?&lt;/p&gt;
&lt;p&gt;Well, no. I already discussed some of the issues with Ripper in &lt;a href=&#34;https://horriblyunderqualified.com/posts/wtf-ruby-pt-1/&#34;&gt;this
post&lt;/a&gt;. Basically,
Ripper uses an embedded domain specific language within &lt;code&gt;parse.y&lt;/code&gt;
which is then converted to &lt;code&gt;ripper.y&lt;/code&gt; with a quite ridiculous Ruby
script, which is then run through Bison and converted into a &lt;code&gt;.so&lt;/code&gt;
file which is then imported by Ripper. This took a while to figure
out, as there wasn&amp;rsquo;t much existing documentation on Ripper.&lt;/p&gt;
&lt;p&gt;There were some other interesting aspects of Ripper, which I might get
around to writing about, such as the &lt;code&gt;dispatch&lt;/code&gt; macros that would call
Ruby functions manually into the VM. Or the metaprogramming aliases
that link to these functions. It&amp;rsquo;s a bit crazy.&lt;/p&gt;
&lt;p&gt;Anyways, while this was happening, I decided to take a short break and
implement return type signatures. This also ended up kind of
tricky. I&amp;rsquo;d implement the return type and get a lot of weird syntax
errors (kind of funny that syntax errors imply an issue in the
interpreter, not an issue in the code). For instance, I&amp;rsquo;d get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ruby/lib/fileutils.rb:1654: syntax error, unexpected :: at EXPR_BEG, expecting keyword_end (SyntaxError)
    ::FileUtils::LOW_METHODS.map {|...
    ^~
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code for context:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	  def _do_nothing(*)end
    ::FileUtils::LOW_METHODS.map {|name| alias_method name, :_do_nothing}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Which&amp;hellip;by the way is not a great error message. If I received that
without knowing that &lt;code&gt;EXPR_BEG&lt;/code&gt; is a lexer state, I&amp;rsquo;d find that pretty
confusing. Anyways, I struggled with that one for a while. I tried
moving around the various existing actions, changing the lexer state,
etc. I even added a unique token (&amp;lsquo;=&amp;raquo;&amp;rsquo; or tDASSOC) and used that as
the return type symbol:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;(&#39; f_args rparen tDASSOC type_sig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given that this should be completely unambiguous, it was kind of
frustrating that it didn&amp;rsquo;t work. Furthermore, the error message didn&amp;rsquo;t
even make much sense. Using the debugger mode for the Ruby parser, I
figured out that when the code was parsed correctly, the lexer was in
the EXPR_BEG state. So&amp;hellip;yeah.&lt;/p&gt;
&lt;p&gt;After banging my head against this wall for a bit, I decided to look
around for other people&amp;rsquo;s implementations of type
annotations. Eventually I stumbled upon &lt;a href=&#34;https://github.com/github/ruby/tree/2.1+type-annotations&#34;&gt;this
branch&lt;/a&gt; on
GitHub&amp;rsquo;s fork of Ruby. To my surprise, when I implemented the rules in
this format, it worked! I had to do some minor tweaking, as how Ruby
sets lexer states changed since 2.1. I still don&amp;rsquo;t exactly know why
this works. My best guess is that it has to do with the
&lt;code&gt;p-&amp;gt;command_start = TRUE&lt;/code&gt; line I put in, since I&amp;rsquo;m fairly sure that&amp;rsquo;s
the main difference.&lt;/p&gt;
&lt;p&gt;I will admit, it&amp;rsquo;s pretty bittersweet that I didn&amp;rsquo;t get to figure out
this on my own, but simply relied on someone else&amp;rsquo;s code. On the other
hand, I&amp;rsquo;ll take the working code.&lt;/p&gt;
&lt;p&gt;After that, I continued my work on Ripper. I tried a few different
approaches, such as adding an annotation to the DSL for type
signatures, using an existing one for constant path references, such
as &lt;code&gt;Foo::Bar&lt;/code&gt;, etc. None of them stuck.&lt;/p&gt;
&lt;p&gt;Then I examined how Ripper actually does function
arguments. Interestingly enough, function arguments are done by
calling a function called &lt;code&gt;new_args&lt;/code&gt;, which, depending on whether or
not you&amp;rsquo;re parsing for Ripper or for the interpreter, goes to
different functions (this is an unfortunate pattern in &lt;code&gt;parse.y&lt;/code&gt; that
is achieved via the C preprocessor). This function is essentially an
alias for a dispatch with params as the function name. Which via some
sort of magic gets turned into an sexpr with params as the
name. Pretty much straight forward as far as Ripper is concerned.&lt;/p&gt;
&lt;p&gt;However, one thing I noticed, was that the arguments were of type
&lt;code&gt;VALUE&lt;/code&gt;, which is pretty much the least useful type in existence. It&amp;rsquo;s
a &lt;code&gt;u_intptr_t&lt;/code&gt; which doesn&amp;rsquo;t print out nicely and tells you zero about
what&amp;rsquo;s actually going on. Interestingly enough, all the grammar rules
output &lt;code&gt;VALUE&#39;s&lt;/code&gt; in Ripper, which makes even less sense. After all,
how do you connect the values into a tree, like a normal parser?&lt;/p&gt;
&lt;p&gt;I then tried some other modifications, such as changing the function
calls, printing out various info, etc. None worked. None even changed
the output of Ripper. What then dawned upon me is a simple yet
slightly horrifying realization. What if I&amp;rsquo;m testing the wrong Ripper?
Now, the reason this hadn&amp;rsquo;t occurred to me before was fairly
simple. When you give Ripper incorrect syntax, it returns nil instead
of the s-expression syntax (which is terrible for error handling by
the way). Since Ripper wasn&amp;rsquo;t returning nil for the type annotations,
but it was returning nil when I tried using the type annotations on
the trunk branch, I figured I was using the correct version of Ripper.&lt;/p&gt;
&lt;p&gt;BUT, there&amp;rsquo;s a caveat here. Since Ripper relies on a &lt;code&gt;.so&lt;/code&gt; file, which
it imports via Ruby&amp;rsquo;s require, I realized that it&amp;rsquo;s quite possible
that it&amp;rsquo;s importing an old &lt;code&gt;.so&lt;/code&gt; file. Now, this wouldn&amp;rsquo;t explain why
none of my changes are showing up while the type annotations parse
correctly, but I supposed it was worth a shot.&lt;/p&gt;
&lt;p&gt;At that point, I decided to try to make a trivial change to Ripper on
the main trunk branch and see if it is visible. I choose a fairly
simple one: since Ruby function arguments don&amp;rsquo;t require parenthesis, I
just removed the &lt;code&gt;paren!&lt;/code&gt; annotation in that rule. Simple. I compile,
build a new version of Ruby, and boom, no change. Therefore, there
should be something wrong with the version of Ripper that I&amp;rsquo;m using,
no?&lt;/p&gt;
&lt;p&gt;I then examine the require path. I add a basic print statement to
print out the location of the file once it&amp;rsquo;s been
required. And&amp;hellip;nope, it&amp;rsquo;s the right file. I even switched it to a
&lt;code&gt;load&lt;/code&gt; with the exact unambiguous path and it still didn&amp;rsquo;t work. So
yeah, that&amp;rsquo;s where I ended. I have no clue why my changes aren&amp;rsquo;t
appearing.&lt;/p&gt;
&lt;p&gt;Frankly it&amp;rsquo;s been a long and frustrating process. I do want to finish
this project, but right now I kind of want a break. I&amp;rsquo;ve had to do a
lot of detective work and careful reading and rereading.&lt;/p&gt;
&lt;p&gt;If I had to give myself some feedback, I&amp;rsquo;d say the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Take notes about everything. Keep a journal that you can update
about all the different methods you&amp;rsquo;ve tried.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Do more preliminary research before trying to write stuff on your
own. Email people, talk to others and get an idea of the context
that your project is in.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It&amp;rsquo;s okay if you don&amp;rsquo;t understand everything. Isolate the subset
that you want or need to understand and focus on that.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Try to do something else instead of just being stuck or
procrastinating. I definitely had some times where I should have
just tossed some part back and worked on a different aspect of my
code. But instead I tried to just keep on grinding and would end up
frustrated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Always do the simplest possible modification first. Don&amp;rsquo;t try
anything fancy.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the other hand, if I were to give some suggestions about Ruby (as a
highly inexperienced insolent developer), here are a few ordered from
possible to less possible:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;parse.y&lt;/code&gt; seriously needs to be split up and cleaned up. Something
as simple as some comments and a little reorganization would do
wonders.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ripper is very very confusing and needs to be either refactored or
rewritten entirely. Adding a DSL via comments and overriding
functions using the C preprocessor just to add an API into the
parser is not exactly great. It&amp;rsquo;s confusing, hard to modify and I&amp;rsquo;m
not even sure how many people are actively using it. Plus there&amp;rsquo;s
little to no documentation. As far as I can tell, &lt;code&gt;Ripper#parse&lt;/code&gt;
doesn&amp;rsquo;t even do anything!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Ruby parser should be decoupled from anything else. I&amp;rsquo;ve noticed
a lot of intermixed code in &lt;code&gt;parse.y&lt;/code&gt;. There&amp;rsquo;s various connections
to compilation, some testing, the Ripper manual calls into the Ruby
virtual machine, etc. In my view, the parser shouldn&amp;rsquo;t be concerned
with all of this. The parser should parse to a simple, platform
independent, usage independent format. After that, what the
interpreter does with the format is out of the parser&amp;rsquo;s purview. It
can compile it to bytecode, export it via a library, heck it could
turn it into a visualization. I understand that this was not done by
design and that there are probably a lot of excellent reasons why
the parser was written this way. But at this point, it&amp;rsquo;s pretty
tricky to write extensions for Ruby. If the parser was independent
of the bytecode compiler, I could conceivably see extensions to Ruby
that just act like a pipeline for the parse tree:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Parse Tree -&amp;gt; Typechecker -&amp;gt; Parse Tree
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or even:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Parse Tree -&amp;gt; Static Analyzer -&amp;gt; Parse Tree
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Ruby parser kinda needs to be rewritten. Sure, when Ruby was
first written, Bison was probably the best option for parsing. But
there&amp;rsquo;s a lot of baggage that comes with Bison. It&amp;rsquo;s hard to debug,
it&amp;rsquo;s nearly impossible to introspect (tooling is straight up
non-existent), and it imposes a lot of odd constraints (e.g. single
file). Sure, this is pretty presumptuous of me to say, as I&amp;rsquo;m not
even half as skilled as the rest of the Ruby team, but comparing the
code for the new MJIT to &lt;code&gt;parse.y&lt;/code&gt; is kind of depressing. The MJIT
code has comments, clear names, goto definition works, etc. The
parser relies on stateful lexing, comment DSLs and various other
hacks to work around Bison&amp;rsquo;s limitations. The old school YY- names
aren&amp;rsquo;t very clear either. A new parser written by hand would allow
for significantly better error handling, better ways of resolving
stateful lexing (communication between the lexer and the parser))
and would be a lot easier to read. Heck, I&amp;rsquo;d do it if I weren&amp;rsquo;t
A. very inexperienced, B. currently in school and C. interested in
other projects.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;rsquo;d like to give my thanks to Tony, my mentor for being extremely
helpful in his advice. I&amp;rsquo;d also like to thank Yusuke Endoh (mame) for
taking the time to answer my questions. Furthermore, I&amp;rsquo;d like to thank
Matz and the Ruby team as a whole for making such a great
language. It&amp;rsquo;s been an invaluable experience learning about one of my
favorite languages. Finally, I&amp;rsquo;d like to thank Google for funding
these projects. It&amp;rsquo;s pretty awesome being able to get paid for open
source contributions. I hope that I can continue to contribute to both
Ruby and to other important open source projects.&lt;/p&gt;
&lt;p&gt;Thanks,
Nicholas&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Stackoverflow Isnt Everything</title>
      <link>https://horriblyunderqualified.com/posts/stackoverflow-isnt-everything/</link>
      <pubDate>Thu, 26 Jul 2018 14:56:46 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/stackoverflow-isnt-everything/</guid>
      <description>&lt;p&gt;There&amp;rsquo;s a lot of memes and jokes online about developers&amp;rsquo; dependency
on StackOverflow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://horriblyunderqualified.com/img/posts/stackoverflow-isnt-everything/stackoverflow_orly.jpg&#34; alt=&#34;My second favorite ORLYcover&#34;&gt;&lt;/p&gt;
&lt;p&gt;And to an extent it&amp;rsquo;s true. StackOverflow is a pretty essential tool
in a modern developer&amp;rsquo;s kit. I&amp;rsquo;ve used it a lot, for everything from
iOS code signing issues to Rails bugs. However, as I&amp;rsquo;ve progressed in
my projects, I&amp;rsquo;ve started to use StackOverflow less and less. There&amp;rsquo;s
a few reasons for this.&lt;/p&gt;
&lt;p&gt;For one, there are problems where StackOverflow straight up doesn&amp;rsquo;t
help. Problems such as writing your own language, or working with
obscure tools or libraries that don&amp;rsquo;t have a whole lot of
users. Basically, if you&amp;rsquo;re going into territory no man (or woman) has
been before, it&amp;rsquo;s unlikely StackOverflow can help you. For instance,
the chances I&amp;rsquo;ll get a decent answer about the inner workings of the
Ruby interpreter through SO are pretty much slim to none.&lt;/p&gt;
&lt;p&gt;Second, there&amp;rsquo;s time limits. If you &lt;em&gt;shudder&lt;/em&gt;, actually ask a question
on SO instead of just looking at previous answers, you might be
looking at a few hours or even a few days before you get a good
answer. That&amp;rsquo;s not a knock against SO, quality takes time. But
sometimes when you have a hard deadline, or are just impatient like
me, a few days isn&amp;rsquo;t good enough.&lt;/p&gt;
&lt;p&gt;And finally, if you&amp;rsquo;re working on the cutting edge, let&amp;rsquo;s say a
prerelease beta of your favorite JS library, or a version of a
language you build from source, then chances are the well intentioned
advice of most StackOverflow users might not apply. Again, not their
fault, just special situation.&lt;/p&gt;
&lt;p&gt;So what do you do? Do you curl up into a ball and wait the time until
you get a StackOverflow answer? Do you give up and quit programming?
Well, you &lt;em&gt;could&lt;/em&gt;, or you could do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Open an issue&lt;/strong&gt; This is especially useful if you&amp;rsquo;re working on
the cutting edge prerelease alpha build, or if you&amp;rsquo;re working on
something that requires niche knowledge that only a few developers
have. Usually in good open source projects people are fairly
responsive and polite. They&amp;rsquo;ll help you with your issue, and maybe
even add new functionality to their software if you ask
politely. Most projects these days use GitHub, but even if they&amp;rsquo;re
using a mailing list or a bug tracker, issues are a great way to
get involved in the open source community.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Email someone&lt;/strong&gt; This is a bit more direct, so it depends on how
urgent your issue is. Often times developers will have a public
email, either on their GitHub or personal website. Of course, don&amp;rsquo;t
do this for your average &amp;ldquo;I forgot a semicolon&amp;rdquo; issue. But it&amp;rsquo;s
fantastic for issues that are specific, somewhat technically
interesting or very very urgent. Just be polite and remember they
aren&amp;rsquo;t your personal tech support.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Read a book&lt;/strong&gt; Contrary to popular belief, programming books
didn&amp;rsquo;t suddenly disappear once StackOverflow became a
thing. There&amp;rsquo;s plenty of great, informative books on basically
every topic imaginable. Not only can they provide good insight into
certain languages and tools, they can give more depth and thought
than even the most thorough Jon Skeet answer. Need an answer that
requires real, capitalized Computer Science? Read a book.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Read the damn code&lt;/strong&gt; Can&amp;rsquo;t make heads or tails of your issue?
Have an error that isn&amp;rsquo;t understandable? Find the source code,
clone the repo and read the damn code. It&amp;rsquo;s fast, effective and you
don&amp;rsquo;t have to talk to anybody. Social interaction? &lt;strong&gt;The
horror&lt;/strong&gt;. Not to mention, you also gain a deeper understanding of
the code you&amp;rsquo;re using. Which means you can be the one to answer the
next StackOverflow question on this topic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Patch the damn code&lt;/strong&gt; Let&amp;rsquo;s say you did read the code. You read
it and there&amp;rsquo;s a glaring issue with the code. Maybe they forgot to
take into account some issue you&amp;rsquo;re having. Maybe it&amp;rsquo;s just
buggy. Well sure you could wait for someone to hold your hand and
fix the code. Or you could fork the repo and just fix it your damn
self. You get experience, open source street cred, and your problem
is solved as fast as you can patch.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And really, depending on StackOverflow for everything is kinda sad. I
get that it&amp;rsquo;s a joke, but behind the joke is a very true reality:
Developers aren&amp;rsquo;t honing their problem solving skills but instead just
relying on StackOverflow to think for them. But really, limiting
yourself to StackOverflow is limiting yourself to what StackOverflow
contributors can help you with. You can&amp;rsquo;t push the envelope or try new
things if you just rely on StackOverflow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Racket School</title>
      <link>https://horriblyunderqualified.com/posts/racket-school/</link>
      <pubDate>Sat, 14 Jul 2018 23:21:37 -0600</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/racket-school/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m waiting for my flight back from Racket School 2018, so I figured I
might as well recommend the event while it&amp;rsquo;s still fresh. Basically,
Racket School is a week long conference/workshop about Racket, the
programming language. It&amp;rsquo;s run by the creators of Racket: Matthias
Felleisen, Robby Findler, and Matthew Flatt. For anybody who learned
Racket in school, that may seem a little odd–&amp;ldquo;Racket, you mean that
language I used in Intro CS five million years ago?&amp;rdquo; But in reality
Racket is far far more than just another Lisp in the Scheme
family. It&amp;rsquo;s a programming language built around designing and
building other languages.&lt;/p&gt;
&lt;p&gt;What does this mean? Basically, Racket has a lot of first class
support for designing small, domain-specific-languages (DSLs). Racket
practices a paradigm called language oriented programming. The way a
Racket programmer attacks a problem is by designing a small DSL to
solve it. It&amp;rsquo;s a very intriguing approach to programming and actually
more common than you&amp;rsquo;d think. For instance, Ruby on Rails essentially
uses a DSL to define model associations and routing. Or JSX, which is
a DSL for designing component hierarchies.&lt;/p&gt;
&lt;p&gt;At Racket School they basically indoctrinate you into the cult of
Racket. They do this by teaching you various uses of Racket, centered
around a particular theme. Last year it was designing the semantics of
programming languages. This year, it was more focused on the general
design of programming languages. This meant that they taught us topics
such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Macros/compile time functions. Granted, pretty familiar to most Lisp
programmers, but Racket has some neat ways of designing macros
(error handling actually works!).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How to use macros to create small languages with different features.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How modules can be languages and vice versa. You pretty much import
a language in Racket, which means that Racket projects often have
multiple files in different languages (that sounds confusing, but
trust me, it isn&amp;rsquo;t).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How to write a parser and add non S-expression syntax to a language
using a language called brag. Essentially you can write Backus-Naur
and it works perfectly. Also includes some ergonomics that other
parser generators like bison/yacc don&amp;rsquo;t have (in my opinion).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Writing a type checker using a language called turnstile. Turnstile
allows you to write essentially the type rules and have it
typecheck. For instance, this is valid turnstile:&lt;/p&gt;
&lt;h2 id=&#34;-f--f-----tin--t-&#34;&gt;[(_ f e &amp;hellip;) ⇐ t ≫
[⊢ e ≫ e- ⇒ tin] &amp;hellip;
[⊢ f ≫ f- ⇐ (-&amp;gt; tin &amp;hellip; t) ]&lt;/h2&gt;
&lt;p&gt;[⊢ (#%app f- e- &amp;hellip;)]]
Granted, it&amp;rsquo;s a little APL-esque, but it&amp;rsquo;s still really cool.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How to implement Prolog in Racket. Okay&amp;hellip;.to be quite honest I got
very lost on that one. But it was still very neat.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The best part of this? They sponsor students (both undergrad and grad)
to come. They will reimburse flights and give you free housing. And
since I have little to no experience in programming languages, and am
only an undergrad, yet managed to get funded, I&amp;rsquo;m pretty sure most to
all of the grad/undergrad kids on this list could get funded.&lt;/p&gt;
&lt;p&gt;But why should you go? Well recently, I had found myself kind of
spinning my wheels with programming languages. I had made some decent
progress in parsing&amp;hellip;but that&amp;rsquo;s kind of like making a really really
good first sentence in your essay. Great, but you now need to write
the rest of the paper. A lot of PLT is really intimidating, with a lot
of dense theory involved. This past week gave me a really good view of
the way forward. In a gist, Racket School is a really good way to get
an excellent high level view of how to develop programming languages.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TL;DR&lt;/em&gt;: Go to Racket School, they will fund you and you will learn so
much your head will explode with lambdas.&lt;/p&gt;
&lt;p&gt;Best,
Nicholas&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wtf Ruby Pt 1: DSL Dyslexia</title>
      <link>https://horriblyunderqualified.com/posts/wtf-ruby-pt-1/</link>
      <pubDate>Sun, 08 Jul 2018 21:41:58 -0600</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/wtf-ruby-pt-1/</guid>
      <description>&lt;h2 id=&#34;preface&#34;&gt;Preface&lt;/h2&gt;
&lt;p&gt;This summer I&amp;rsquo;ve been working on the Ruby language adding type
annotations to the grammar. However, the Ruby codebase is rather
challenging. There&amp;rsquo;s not a whole lot of documentation (at least in
English), there&amp;rsquo;s a fair amount of C preprocessor hacking, and there&amp;rsquo;s
a few tricky scripts attached. I&amp;rsquo;ve decided to document these
challenges in this blog. I hope that they&amp;rsquo;re useful to anybody who
decides to work on the Ruby codebase, and I also hope that I can use
these notes to improve the codebase myself. If any Ruby maintainers
read this, I apologize in advance for any seemingly critical
language. I totally respect and appreciate your contributions to Ruby
and to the open source community as a whole. Please understand that
these criticisms are coming from a place of respect and learning.&lt;/p&gt;
&lt;h2 id=&#34;dsl-dyslexia&#34;&gt;DSL Dyslexia&lt;/h2&gt;
&lt;p&gt;Today I&amp;rsquo;m going to talk about Domain Specific Languages (DSLs),
specifically the one in Ripper. Ripper, for those who don&amp;rsquo;t know, is a
Ruby library that consists of a Ruby parser. Ripper allows developers
to literally &amp;ldquo;rip apart&amp;rdquo; the Ruby code into tokens, a process called
lexing, or into an Abstract Syntax Tree (AST), a process called
parsing. An AST is essentially the Ruby code turned into a general,
homogeneous form independent of syntax.&lt;/p&gt;
&lt;p&gt;Now the way that Ripper is generated is rather interesting. Instead of
rewriting the parser in Ruby, the developers of Ruby opted to take the
existing Ruby parser and extend it to also work with Ripper. This
makes the most sense, as Ruby has a rather complex grammar with a lot
of little details. It would have been far too time consuming and
painful to recreate the parser in Ruby. Furthermore, if new grammar
rules were to be added, two parsers would have to be updated.&lt;/p&gt;
&lt;p&gt;So how did the developers extend the Ruby parser? Well they
implemented a DSL. Domain Specific Languages are a really interesting
form of computer languages. They are built for very specific usecases,
such as quickly writing data models, or defining objects in a graphics
engine, as opposed to general purpose languages like Python, Ruby, C,
etc. They can allow for immense expressiveness in a clear, concise
manner. However, if they are not well documented or understood, they
can be confusing, even alien. The Ruby community as a whole tends to
use DSLs a fair amount. For instance, Ruby on Rails uses a DSL to help
programmers write web applications with minimal boilerplate.&lt;/p&gt;
&lt;p&gt;But back to the Ruby parser. The way that the developers implemented
this DSL was by adding comments into the Ruby parser file,
&lt;code&gt;parse.y&lt;/code&gt;. While this is a completely understandable solution, as a
result, a fair bit of complexity was introduced. You see, the Ruby
parser is created using Bison, Bison being a very popular parser
generator. Parser generators allow programmers to create a parser by
simply defining some grammar rules in&amp;hellip;you guessed it, a DSL. So by
adding a second DSL through comments, the developers put two DSLs in
one file. That won&amp;rsquo;t be confusing, right?&lt;/p&gt;
&lt;p&gt;Which brings us to this past day. I decided to read the code in
&lt;code&gt;ext/ripper/tools&lt;/code&gt;, where the Ripper DSL is parsed. There&amp;rsquo;s a fun
bit of code in &lt;code&gt;generate.rb&lt;/code&gt; where it takes the Ripper annotations:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    /*% ripper[brace]: rb_ary_new3(1, get_value($1)) %*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and, using a regular expression, or regex (&lt;code&gt;%r&amp;lt;/\*% *ripper(?:\[(.*?)\])?: *(.*?) *%\*/&amp;gt;&lt;/code&gt;) splits them into:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$1 = &amp;quot;brace&amp;quot;
$2 = &amp;quot;rb_ary_new3(1,get_value($1))&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is done implicitly in Ruby, as &lt;code&gt;$n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is an integer) are
magic global variables that refer to the nth match in the regular
expression. Note that it&amp;rsquo;s &lt;code&gt;rb_ary_new3(1...&lt;/code&gt;, not $1. I actually had
to double check that I didn&amp;rsquo;t accidentally delete the dollar sign. I
don&amp;rsquo;t know why it&amp;rsquo;s there.&lt;/p&gt;
&lt;p&gt;Anyways, what&amp;rsquo;s interesting is that &lt;code&gt;generate.rb&lt;/code&gt; initializes a DSL
object that takes these two variables, well, &lt;code&gt;$2&lt;/code&gt; and &lt;code&gt;($1 || &amp;quot;&amp;quot;).split(&amp;quot;,&amp;quot;)&lt;/code&gt; (which is probably an attempt to put $1 in an
array?). The DSL object&amp;rsquo;s constructor, as defined in &lt;code&gt;dsl.rb&lt;/code&gt;,
proceeds to do a few things which I&amp;rsquo;ll get to and then evaluates
&lt;code&gt;$2&lt;/code&gt;. Kinda like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eval(&amp;quot;rb_ary_new3(1, get_value($1))&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Therefore all the annotations in parse.y should be valid Ruby!
But&amp;hellip;&lt;code&gt;$1-$9&lt;/code&gt; aren&amp;rsquo;t defined. Well, actually&amp;hellip;they are. Let&amp;rsquo;s take a
look at the code above this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# create $1 == &amp;#34;$1&amp;#34;, $2 == &amp;#34;$2&amp;#34;, ...&lt;/span&gt;
    re, s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;upto(&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
      re &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(..)&amp;#34;&lt;/span&gt;
      s &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#{&lt;/span&gt; n &lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#e6db74&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#{&lt;/span&gt; re &lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;At first I didn&amp;rsquo;t really pay attention to this code. But the comment
caught my eye the second time around. So I read it a little more
carefully and realized that this code is automatically generating
values for $1-$9!&lt;/p&gt;
&lt;p&gt;How, pray tell is it doing that? Well one side effect of &lt;code&gt;$n&lt;/code&gt; being
magic global variables is that they cannot be directly
mutated. Therefore something like &lt;code&gt;$1 = &#39;mike&#39;&lt;/code&gt; doesn&amp;rsquo;t
work. Therefore, to get around this issue, the developers created this
hack.&lt;/p&gt;
&lt;p&gt;Basically, we build up to strings, &lt;code&gt;re&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. &lt;code&gt;re&lt;/code&gt; is actually a
regular expression, one of the form
&lt;code&gt;/(..)(..)(..)(..)(..)(..)(..)(..)(..)(..)/&lt;/code&gt;, basically 10
&lt;code&gt;(..)&lt;/code&gt; in a row. The string &lt;code&gt;s&lt;/code&gt; on the other hand consists of
&lt;code&gt;&amp;quot;$1$2$3$4$5$6$7$8$9&amp;quot;&lt;/code&gt;. The final operation is a match operation,
namely it matches &lt;code&gt;re&lt;/code&gt; against &lt;code&gt;s&lt;/code&gt;. Now, at first glance, this appears
to do nothing. There&amp;rsquo;s no apparent side effects and no variables bound
except &lt;code&gt;re&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;, which are never used again. EXCEPT, if you
remember the meaning of &lt;code&gt;$n&lt;/code&gt;. You see, in regular expressions, &lt;code&gt;(..)&lt;/code&gt;
means match exactly two characters, that&amp;rsquo;s it. So when you run &lt;code&gt;re&lt;/code&gt;,
basically 10 of these &lt;code&gt;(..)&lt;/code&gt;, against &lt;code&gt;s&lt;/code&gt;, you match two characters 10
times. For instance, the first match, which will be stored in &lt;code&gt;$1&lt;/code&gt;
is&amp;hellip;yep &lt;code&gt;&amp;quot;$1&amp;quot;&lt;/code&gt;, the second match, stored in &lt;code&gt;$2&lt;/code&gt; is &lt;code&gt;&amp;quot;$2&amp;quot;&lt;/code&gt;, and so
on.&lt;/p&gt;
&lt;p&gt;To recap, this code generates a regular expression and generates a
string to implicitly bind 10 global variables. Pretty gnarly.&lt;/p&gt;
&lt;p&gt;But that&amp;rsquo;s not the end of it! After that, I started to wonder how in
the world the &lt;code&gt;eval&lt;/code&gt; function was working. After all, these functions
aren&amp;rsquo;t naturally in the Ruby scope, there aren&amp;rsquo;t any other files
imported in &lt;code&gt;dsl.rb&lt;/code&gt;, and there isn&amp;rsquo;t a binding passed along to
eval. Also, something weird would happen. I would try to print out the
output of the function call like such:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;puts(rb_ary_new3(1, get_value($1)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Only to get &lt;code&gt;rb_ary_push($1, get_value($3))&lt;/code&gt; as my output. Kinda weird&amp;hellip;&lt;/p&gt;
&lt;p&gt;So I scrolled down a little and found to my horror: &lt;code&gt;def method_missing&lt;/code&gt;. To quote Gary Bernhardt,
&lt;a href=&#34;https://www.destroyallsoftware.com/talks/wat&#34;&gt;wat&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For those who don&amp;rsquo;t know, &lt;code&gt;method_missing&lt;/code&gt; is a rather infamous
function in Ruby. When you attempt to call a function that doesn&amp;rsquo;t
exist in Ruby, Ruby normally raises a &lt;code&gt;MethodError&lt;/code&gt;, which is fairly
standard, rather sensible, basically an overall normal thing to do. But
the demented, insane geniuses that are the Ruby developers decided
that this isn&amp;rsquo;t flexible enough, so they gave an alternative:
&lt;code&gt;method_missing&lt;/code&gt;. &lt;code&gt;method_missing&lt;/code&gt;, when defined, allows you to
implicitly catch the error. Instead of raising a &lt;code&gt;MethodError&lt;/code&gt;, Ruby
calls your &lt;code&gt;method_missing&lt;/code&gt; and passes it the name of the method you
tried to call, along with any potential arguments you might
passed. This is NOT advised. Most Ruby style guides heavily discourage
&lt;code&gt;method_missing&lt;/code&gt;. Granted, the developers of Ruby are not most Ruby
programmers. But still, it&amp;rsquo;s not exactly common behavior.&lt;/p&gt;
&lt;p&gt;Anyways, this &lt;code&gt;method_missing&lt;/code&gt; does a few different things. For
instance, if your DSL annotations end in a bang, i.e. they match this
regex &lt;code&gt;/!\z/&lt;/code&gt;, then it outputs this in ripper.y:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{VALUE v1,v2;v1=$1;v2=dispatch1(assoclist_from_args,v1);$$=v2;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or, if they begin with an id, you just get the event back, as something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{$$=idCOLON2}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can&amp;rsquo;t actually find any example of this in &lt;code&gt;parse.y&lt;/code&gt;, but we&amp;rsquo;ll
assume it&amp;rsquo;s used somewhere. And for the rest you basically just get
the same function that you started with (the value of &lt;code&gt;$2&lt;/code&gt;). That&amp;rsquo;s why
the &lt;code&gt;puts(rb_ary_new3(1, get_value($1)))&lt;/code&gt; gives &lt;code&gt;rb_ary_push($1, get_value($3))&lt;/code&gt; as the output. This gives the following in ripper.y (the output of this DSL):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$$=rb_ary_push($1, get_value($3));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Oh yeah, and if you happen to have an annotation called &lt;code&gt;opt_event&lt;/code&gt;,
that actually does call a method called &lt;code&gt;opt_event&lt;/code&gt;. It basically does
something similar with a few minor changes (I believe a nil check and
some other stuff).&lt;/p&gt;
&lt;p&gt;In conclusion, this has been an excellent exercise in interesting Ruby
code. In all seriousness, I wouldn&amp;rsquo;t really advise writing Ruby code
in this manner, but I have a serious amount of respect for the person
who wrote this code and thought of it in this manner. I certainly
would have written it in a more *ahem* pedestrian manner.&lt;/p&gt;
&lt;p&gt;Indeed, I might decide to attempt a refactor of this code, or at the
very least some heavy documentation. Right now I&amp;rsquo;m holding off on
refactoring simply because I don&amp;rsquo;t know the whole picture and I don&amp;rsquo;t
know whether my refactoring attempts would actually fix anything, or
if it would just miserably fail due to some detail of which I&amp;rsquo;m not
aware. The developers of Ruby are smart people and I can&amp;rsquo;t claim to
know better than them.&lt;/p&gt;
&lt;p&gt;In the next post I&amp;rsquo;ll explain where all those weird &lt;code&gt;dispatch&lt;/code&gt;
functions came from and what they&amp;rsquo;re doing.&lt;/p&gt;
&lt;p&gt;Hope this has been helpful!&lt;/p&gt;
&lt;p&gt;Nicholas&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Graphql APIs</title>
      <link>https://horriblyunderqualified.com/posts/graphql-apis/</link>
      <pubDate>Sat, 23 Jun 2018 02:45:51 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/graphql-apis/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been using GraphQL for almost a year now. I&amp;rsquo;ve used it in a few
small hackathon projects, along with the &lt;a href=&#34;https://stuyspec.com&#34;&gt;Stuyvesant Spectator
site&lt;/a&gt;. I like using GraphQL because it&amp;rsquo;s rather
easy to query complicated relations, especially for React
components. On StuySpec it allowed us to split the fetching logic into
smaller, more granular queries, which got rid of the large up front
fetch that we previously had (not that you need GraphQL to solve that,
you can easily use query params). That being said, I&amp;rsquo;ll preface this
post by saying that I&amp;rsquo;m not necessarily a GraphQL evangelist. GraphQL
has its pros and cons, just like any other tool.&lt;/p&gt;
&lt;p&gt;When I write GraphQL APIs, I use Rails with graphql-ruby. I chose this
combination because I was converting the Stuyvesant Spectator&amp;rsquo;s Rails
REST API to GraphQL and I didn&amp;rsquo;t want a full rewrite. Also, I do like
Rails and tend to reach for it in need.&lt;/p&gt;
&lt;p&gt;After a few months, I really started to like graphql-ruby. For one,
it&amp;rsquo;s damn easy to use. I basically write a few GraphQL ObjectType
definitions, add a few queries, and the magic of Rails takes care of
the rest. Since the ObjectTypes are basically using the Rails models
underneath the hood, all the usual Rails associations still work. If I
have a one to many relation on Articles to Comments (an Article
&lt;code&gt;has_many&lt;/code&gt; Comments), all I need to do is specify a &lt;code&gt;comments&lt;/code&gt; field
on the Article ObjectType that has a type of an array of Comment
ObjectTypes. Basically, ActiveRecord came to the rescue.&lt;/p&gt;
&lt;p&gt;However, not everything in the Rails + graphql-ruby stack is
great. For instance, there&amp;rsquo;s no real good solution to
authentication. I had to manually work around Devise Token Auth with
some semi messy code for StuySpec. And authorization isn&amp;rsquo;t great
either. The official solution for graphql-ruby requires a Pro
membership which costs 900 dollars a year. Yeah&amp;hellip;no. Other solutions
exist, but they&amp;rsquo;re not that mature.&lt;/p&gt;
&lt;p&gt;But these are the minor problems. The elephant in the room came to me
when I was writing my 2nd or 3rd GraphQL on Rails API. I looked at my
code and I recognized barely anything from old school Rails. I don&amp;rsquo;t
use Rails views. I use exactly one controller (GraphqlController). I&amp;rsquo;m
not using RESTful resources. Okay, sure, I&amp;rsquo;m using ActiveRecord with
migrations. But why do I need a framework for an ORM? I felt like I
was using an SUV for the seat warmer.&lt;/p&gt;
&lt;p&gt;So I decided to check out the other side of the fence. Namely,
Node. After all, isn&amp;rsquo;t that where it all started? GraphQL.js is the
&amp;ldquo;reference implementation&amp;rdquo; of GraphQL. But with Node comes plenty of
other problems. Namely, it&amp;rsquo;s just &lt;em&gt;so&lt;/em&gt; &lt;em&gt;damn&lt;/em&gt; &lt;em&gt;tedious&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;GraphQL in Rails is literally installing a library, writing a few
field types, and that&amp;rsquo;s it. And in theory that&amp;rsquo;s also GraphQL in
Node. Except you have to link resolvers to a database manually. Oh but
you need to set up an ORM for the database. And then get migrations to
work. Oh and then set up the actual server. And then figure out a sane
organization for the files. All the while trying to understand
documentation that uses varying generations of JavaScript. Gotta love
decorators in your documentation when it&amp;rsquo;s not even a Stage 3
proposal! Or ES6 imports when they &lt;em&gt;barely&lt;/em&gt; work in vanilla
Node. Look, I get it, you want the new shiny, but &lt;strong&gt;please&lt;/strong&gt; don&amp;rsquo;t
make me transpile my server.&lt;/p&gt;
&lt;p&gt;However I digress. In short, running your own GraphQL server is perfectly
doable, but damn, is it tedious. And maybe coming from a world of
Express or Flask that&amp;rsquo;s fine, but coming from the nice and smooth
world of Rails, it felt like building a Lego Death Star out of 1x2
blocks.&lt;/p&gt;
&lt;p&gt;And really, this is symptomatic of a more fundamental problem; the
Node community many of the lessons of Rails. In their rush to get on
the hype train, Node developers threw out the baby with the
bathwater. They forgot what made Rails so effective. DHH et
al. realized that most web apps fall into the same patterns. So they
decided to take some simple, tested solutions to these problems, and
codify them into a framework. Ideas like Model View Controller,
Convention over Configuration, Don&amp;rsquo;t Repeat Yourself, helped make
Rails into a really fantastic tool. If I had to choose a particular
slogan for why I love Rails, it would be &amp;ldquo;Automate the Boring Parts&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Sure, Rails has its messy bits. There&amp;rsquo;s way too much magic, Rails
views are looking pretty out of date, and the community can be a
little dogmatic. But it became popular for a reason.&lt;/p&gt;
&lt;p&gt;Why can&amp;rsquo;t we do the same for GraphQL? Why can&amp;rsquo;t we automate the boring
parts? And why can&amp;rsquo;t we make it GraphQL first? Instead of building a
REST framework that tacks on GraphQL at the last second, why don&amp;rsquo;t we
build it from the ground up around GraphQL? These are all questions
that have been ringing around in my mind. I might very well make this
framework.&lt;/p&gt;
&lt;p&gt;And if I were to make it, here are some of the features I would add:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Simple, but declarative models. Let&amp;rsquo;s be real here, models in Rails
are confusing as hell. I remember opening my first model file and
wondering where all the code was. I&amp;rsquo;d probably combine ObjectTypes
and Rails models into a single file that declares the database
schema and then also contains the fields.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instead of Model View Controller, how about Model Resolver Query?
Queries are the entrypoints for GraphQL, resolvers glue together the
models (taking the place of controllers) and models contain most of
the actual validation, fetching, business logic code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Query shortcuts. I&amp;rsquo;ve written a fair amount of ArticleById
queries. It&amp;rsquo;d be nice to have an automatic bit of syntactic sugar
for these. Something like &amp;ldquo;queryable_on :id&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Code generation. Cause who likes writing boilerplate?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That&amp;rsquo;s all I have now. Oh and the name of this prospective framework?
Lattice. Cause, get it? A Graph version of Rails?&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;Oh everyone&amp;rsquo;s a critic.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boring Ass Classes</title>
      <link>https://horriblyunderqualified.com/posts/boring-ass-classes/</link>
      <pubDate>Wed, 14 Mar 2018 23:01:57 -0400</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/boring-ass-classes/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s imagine you&amp;rsquo;re a first year physics student. You&amp;rsquo;ve never taken
a physics class in your life. You&amp;rsquo;ve never even conducted a simple
physics experiment in your life. The only thing you know about physics
is that it&amp;rsquo;s used to make bridges and it has something to do with
electricity, motion, and gravity. You like the idea of making bridges,
so you decided to become a physics major. So you take your first class
and you realize that your professor doesn&amp;rsquo;t know the first thing about
bridges. Sure, maybe ten years ago they dabbled in building one, maybe
they even build a Popsicle stick one every now and then. But a real
life bridge? Nope. Instead, they go over calculus and Lagrangians,
maybe harmonic motion too.&lt;/p&gt;
&lt;p&gt;You start to get really really confused and then really really
bored. When are we going to make bridges? Looking at the courses
offered, you see a basic bridge building class. Only issue? It&amp;rsquo;s a
junior level class with partial differential equations as a
prerequisite. And after talking with other students, you hear that the
material is horribly outdated; the professor only teaches how to build
wooden bridges.&lt;/p&gt;
&lt;p&gt;This is basically NYU CS in a gist. Most NYU students take Intro to
Computer Programming, followed by Data Structures, followed by
Computer Systems Organization. In these classes, you learn the
following languages: Java and C. That&amp;rsquo;s it. And frankly it doesn&amp;rsquo;t get
much better. After CSO, there&amp;rsquo;s Operating Systems and Basic
Algorithms, two courses that use maybe a little bit of C and that&amp;rsquo;s
it.&lt;/p&gt;
&lt;p&gt;Now C and Java are great languages. I personally like coding in them a
lot, and I find the material in all the NYU classes rather interesting
and fun. Only issue? I&amp;rsquo;m not your average NYU CS student. I&amp;rsquo;m already
sold on computer science and programming. I&amp;rsquo;ve have real code pushed
to production, learned other languages besides Java and C, even taught
myself some theory. But other kids haven&amp;rsquo;t. They don&amp;rsquo;t know what real
software development looks like. So when they see pointer arithmetic
and the tedium of Java, they start to think that this is it, that this
is the entirety of software development. Frankly if I thought that C
and Java were the &lt;em&gt;ne plus ultra&lt;/em&gt; of software development, I probably
wouldn&amp;rsquo;t be a programmer.&lt;/p&gt;
&lt;p&gt;And by the way, I&amp;rsquo;m not saying we should dumb down CS courses or
&lt;a href=&#34;https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/&#34;&gt;create
JavaSchools&lt;/a&gt;.
If I had my way CS curricula would be &lt;strong&gt;brutal&lt;/strong&gt;. But you gotta give
some sort of incentive. You gotta sweeten the deal. Maybe make a web
dev class a mandatory part of the curriculum. Or give a Ruby or Python
class. Just &lt;em&gt;something&lt;/em&gt; to lessen the onslaught of Java and C and
maybe, just maybe give an inkling of what their future career is going
to look like.&lt;/p&gt;
&lt;p&gt;Granted, this is a CS degree, not a programming or software
development degree. But since NYU does not offer a programming or
software development degree, and since most people who go through a CS
degree plan on becoming a software developer, perhaps the degree
should teach some aspects of software development.&lt;/p&gt;
&lt;p&gt;For instance, why aren&amp;rsquo;t there projects with actual, y&amp;rsquo;know, user
interfaces? Look, I get it, Java and C are standard, bread and butter
languages. But they also are terrible terrible languages for creating
user interfaces. Give students some basic webdev and let them build a
simple user facing application. Not only do they get a semi realistic
experience, but they also get useful skills. Skills like usability,
design, aesthetics, performance optimization (when it counts), handling
clients, etc. And this shouldn&amp;rsquo;t be the capstone or the climax of the
degree. This should be like the first or second course students
take. Lure them in, then slam them with the brutal pointers and
functional programming classes.&lt;/p&gt;
&lt;p&gt;Finally, do you know why I know that NYU isn&amp;rsquo;t doing a good job of
this?  Because &lt;a href=&#34;https://albertsucks.com/&#34;&gt;Albert Sucks&lt;/a&gt; and if a
website sucked this bad in a school where they actually taught
software development, students would have built a better Albert. But
they didn&amp;rsquo;t. And that says everything about NYU.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C Is Cool</title>
      <link>https://horriblyunderqualified.com/posts/c-is-cool/</link>
      <pubDate>Tue, 06 Mar 2018 16:09:56 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/c-is-cool/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been using C for my classes and I can&amp;rsquo;t help but be really really
happy about that. I&amp;rsquo;ve played with C before. Well, actually, C was my
first language. I tried learning it as a stepping stone to Objective C
and iOS development, but I quickly gave it up after getting to
pointers and arrays. Granted, I was like 11. After that, I&amp;rsquo;ve played
with C in various places. First, I had to use C++ in an internship,
where I got to play around with performance optimization and
profiling. Then, last year because I was bored with using Java in my
classes, I started to write some data structures in C. Just basic
stuff like linked lists, binary trees, maybe a hash table. I found it
really intriguing and a lot of fun to play with. Oh sure, segfaults
were annoying and the whole lack of decent typing or safety led to
some less than safe code. But overall it was a good experience.&lt;/p&gt;
&lt;p&gt;Now, this semester, I&amp;rsquo;m in Computer Systems Organization, a class with
a lot of C programming. And honestly I&amp;rsquo;m having the time of my life. C
is just such a &lt;em&gt;cool&lt;/em&gt; language. Oh sure, it doesn&amp;rsquo;t have the fancy
features of Python/Ruby, the metaprogramming of Lisp or the libraries
of JavaScript. But it&amp;rsquo;s just so damn minimal. I&amp;rsquo;ve been trying to
learn about compilers and language development (albeit at a glacial
pace, I do have other things in my life) and C is just such an
intriguing language from a design standpoint.&lt;/p&gt;
&lt;p&gt;Like take lexical scoping. C doesn&amp;rsquo;t allow you to declare functions in
functions. The best you can get are function pointers. But as a
result, functions and their lexical scope map cleanly onto stack
frames. You don&amp;rsquo;t have to worry about closures or about resolving
scope dynamically. Hell, you can&amp;rsquo;t call functions before they&amp;rsquo;re
declared, forcing you to use header files. This means that the map
from code to implementation is just about the simplest thing. You can
resolve scope just by looking at the code. And that&amp;rsquo;s so damn cool.&lt;/p&gt;
&lt;p&gt;Or how you can count memory allocations. High level languages are nice
and all, but you often run into awkward situations where one line of
code is mysteriously and disproportionately slowing down your
program. In C? Not so much. Oh sure, malloc is amortized and can be
slower than you expect. But generally when you&amp;rsquo;re writing C, you know
what you&amp;rsquo;re getting. In a language like Ruby or Python or JavaScript,
I can&amp;rsquo;t tell you how many bytes I&amp;rsquo;ve allocated. Hell, I probably
wouldn&amp;rsquo;t even get within 100 bytes of the right answer. But in C?
I could probably tell you down to plus or minus 2 bytes.&lt;/p&gt;
&lt;p&gt;Of course, there&amp;rsquo;s plenty of annoying issues, not to mention the whole
concept of memory safety. But it&amp;rsquo;s probably the most fun I&amp;rsquo;ve had just
programming, barring messing around with Lisps. Now if only I could
find a good project to write in C&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Rails in 2018</title>
      <link>https://horriblyunderqualified.com/posts/using-rails-in-2018/</link>
      <pubDate>Sat, 03 Mar 2018 17:06:43 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/using-rails-in-2018/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m a huge fan of Ruby on Rails. I&amp;rsquo;ve used it for numerous hackathons
and various other projects. The Stuyvesant Spectator
&lt;a href=&#34;https://stuyspec.com&#34;&gt;website&lt;/a&gt; is built with a Rails back end and the
previous iteration of this blog was my first Rails project. However,
as a shameless advocate of Rails, I get to hear a lot of inaccurate
ideas about Rails, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Isn&amp;rsquo;t Rails dead? I don&amp;rsquo;t know anybody who uses it&lt;/li&gt;
&lt;li&gt;Rails is too confusing&lt;/li&gt;
&lt;li&gt;Why should I use Rails when I can use Node?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;rsquo;d like to address these concerns and give some tips on how to learn
and use Rails in 2018.&lt;/p&gt;
&lt;p&gt;First, let&amp;rsquo;s address the elephant in the room: is Rails dead? Well,
no. Not by any reasonable standard. Many companies, such as GitHub,
Shopify, Netflix, Crunchbase, Soundcloud, Airbnb, etc. use
Rails. Furthermore, Rails development is still ongoing at a rapid
pace, with Rails 5.2 beta recently released.&lt;/p&gt;
&lt;p&gt;However, when people usually ask this question, what they usually mean
is &amp;ldquo;I haven&amp;rsquo;t heard anything about Rails from Hacker
News/Reddit/Medium&amp;rdquo;. And yes, by that metric, Rails is pretty damn
dead. But before we start getting out the pallbearers, let&amp;rsquo;s analyze
precisely why Rails is no longer talked about. Partially it&amp;rsquo;s because
there&amp;rsquo;s not a lot to talk about. Developer evangelists don&amp;rsquo;t advertise
it anymore. After all, developers who use Rails don&amp;rsquo;t need to be
convinced that Rails works. They just use it.&lt;/p&gt;
&lt;p&gt;Second, is what I call the &lt;em&gt;bootcamp effect&lt;/em&gt;. Basically, as companies
started to want Rails developers, bootcamps started teaching
Rails. This lead to a few major issues. First, there were a bunch of
Rails developers on the scene who did not understand the core ideas of
Rails (MVC, CoC), who did not understand Ruby, and basically did not
understand software development. As they started to write bad code,
they began to wonder why their applications weren&amp;rsquo;t maintainable, why
their code wasn&amp;rsquo;t good. And the easy target? Rails. I mean, just look
at the sheer amount of StackOverflow questions on Rails. It&amp;rsquo;s fairly
clear that from most of the questions the inquirer doesn&amp;rsquo;t actually
know Ruby. They just &amp;ldquo;know&amp;rdquo; Rails. Then, as new tools such as Node and
Golang came out, developers switched to them and suddenly their code
was so much better. Well&amp;hellip;not quite. It&amp;rsquo;s more likely they just got a
clean slate. Or perhaps they actually decided to learn the underlying
language instead of just relying on Rails&amp;rsquo; DSL. After that, the
bootcamp graduates started making overgeneralizations about Rails. Oh,
you know, the usual, &amp;ldquo;A is always better than B because&amp;hellip;&amp;rdquo; or &amp;ldquo;Don&amp;rsquo;t
use B because xyz&amp;rdquo;. Partially true, but not completely.&lt;/p&gt;
&lt;p&gt;Finally, there&amp;rsquo;s the parts of Rails that legitimately are dead. For
instance, CoffeeScript and the Asset Pipeline. Yeah&amp;hellip;while you could
totally use them in 2018, they&amp;rsquo;re definitely out of date. I&amp;rsquo;ll get
back to this, but front end development is definitely one area where
Rails has fallen behind.&lt;/p&gt;
&lt;p&gt;To summarize, Rails is not dead, but simply no longer hyped up by the
&lt;em&gt;bootcamp effect&lt;/em&gt; or by developer evangelism. There are plenty of
companies that use Rails and it&amp;rsquo;s not going away anytime soon.&lt;/p&gt;
&lt;p&gt;Though to be entirely fair, the &lt;em&gt;bootcamp effect&lt;/em&gt; is not entirely the
fault of the bootcamp graduates. Rails is a pretty terrible
my-first-framework. Which brings us to the next comment: Rails is
confusing. Honestly&amp;hellip;I don&amp;rsquo;t disagree. Rails abstracts away a lot of
important aspects of developing a basic REST application, such as
routing, handling requests and accessing a database. For people who
already know how these aspects work, these abstractions are extremely
useful for developing flexible software quickly. But for a beginner?
Not great. Part of the reason Express is so likeable is because it&amp;rsquo;s a
very easy mental model: Request -&amp;gt; Router -&amp;gt; Callback. Rails doesn&amp;rsquo;t
have that easy mental mode. Not to mention, features like magical auto
imports can be extremely confusing at first. But again, Rails was not
designed for bootcamp graduates. It was designed for people who
understood Ruby, understood web development and wanted to
automate the boring parts.&lt;/p&gt;
&lt;p&gt;Most importantly, Rails was designed to be extreeeeemly
opinionated. The whole concept of convention over configuration was an
attempt to simplify the structure of a web application by enforcing
certain standards. This makes total sense for an experienced developer
who understands concepts like Model-View-Controller, or aphorisms like
&amp;ldquo;fat models, skinny controllers&amp;rdquo;. But for a beginner? All the little
opinionated aspects and strictness makes it really hard to just write
code.&lt;/p&gt;
&lt;p&gt;So why should you use Rails in 2018? Well there&amp;rsquo;s a few reasons. But
first, a demo.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Without a single line of code, I managed to add basic CRUD
functionality for articles. Again, terrible for beginners. But for a
developer who doesn&amp;rsquo;t want to spend hours on controller boilerplate?
Amazing.&lt;/p&gt;
&lt;p&gt;And this easiness doesn&amp;rsquo;t just apply to code generation. Take GraphQL
for instance. In the Node world, writing GraphQL resolvers is a bit of
a nightmare. You have to manually write every single resolver for
every field. Want to get comments from an article model? Great! You
need to write a resolver to fetch the comments. Granted, there are
some shortcuts, like
&lt;a href=&#34;https://github.com/stems/join-monster&#34;&gt;join-monster&lt;/a&gt; and other
libraries. But it&amp;rsquo;s just a damn pain. You need to find an ORM, connect
the ORM to the database, connect the ORM to the GraphQL library, then
write out the schema definitions, blah blah blah. In Rails? It&amp;rsquo;s as
simple as adding the GraphQL gem, defining the fields in your object
type and writing a query. Want nested data? Define the types and
Rails&amp;rsquo; built in ORM, ActiveRecord takes care of the rest.&lt;/p&gt;
&lt;p&gt;Again, quick demo:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;And if you do want more fine grained control of your fields, well you
can also just define a field using a Ruby lambda and have it resolve
to whatever you want.&lt;/p&gt;
&lt;p&gt;You see, the main power of Rails is its&amp;rsquo; cohesiveness. Every piece of
the puzzle, from the web server to the ORM to the GraphQL gem
integrates perfectly. You don&amp;rsquo;t have to string npm package after npm
package together just to get the basics down. You don&amp;rsquo;t have to
navigate tutorials that only handle 4 out of the 10 packages you&amp;rsquo;re
using. It just works.&lt;/p&gt;
&lt;p&gt;So, without further ado, here are some tips on Rails development in
2018.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Use the API mode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s be honest here. Front end development is a bit of a runaway
train right now. The Angular hype was quickly overtaken by the React
hype which is now being challenged by the Vue hype. Gulp/grunt was
replaced by Webpack which might be replaced by Parcel. And while Rails
has tried to keep up with tools like Webpacker, it&amp;rsquo;s just a lost
cause. Webpacker inherently ties your Rails application to webpack and
forces you to couple your SPA with your API. And for what? Rails views
and Rails controllers are coupled because they integrate
tightly. There&amp;rsquo;s no equivalent reason to couple your front end SPA
with your back end.&lt;/p&gt;
&lt;p&gt;Meanwhile, Rails shipped an API mode in 5.1 that strips out all the
front end code and leaves a simple, elegant REST API. This means you
get all the wonderful generators, tight integration and easy of use
that people love about Rails, minus the outdated asset pipeline.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try GraphQL Ruby&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I can&amp;rsquo;t emphasize enough how great GraphQL Ruby is. It integrates so
well into the Rails ecosystem and it gives a better development
experience than anything I&amp;rsquo;ve found in Node for GraphQL.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Learn Ruby&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I mean, this should go without saying. But Rails is not Rails without
Ruby. Not knowing Ruby is like trying to write React code while not
knowing JavaScript. It just doesn&amp;rsquo;t work.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Don&amp;rsquo;t Listen To the Haters&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Just because all you hear is Node, Golang and Elixir, doesn&amp;rsquo;t mean
other frameworks are bad or dying. Rails is a fantastic framework that
only keeps getting better over the years. Check it out, or give it
another chance.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Explaining Redux</title>
      <link>https://horriblyunderqualified.com/posts/explaining-redux/</link>
      <pubDate>Mon, 26 Feb 2018 13:31:22 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/explaining-redux/</guid>
      <description>&lt;p&gt;Redux is one of those concepts that is so damn hard to explain, and
even harder to understand. For me at least, React was a lot easier to
understand at a high level. I mean, React at a high level is basically
just objects minus inheritance plus one way data flow. Or function
composition with some enclosed state if you&amp;rsquo;re into functional
programming. Sure, there&amp;rsquo;s a lot more to it once you get into the
nitty gritty, but really that&amp;rsquo;s all you need to know to start writing
React code.&lt;/p&gt;
&lt;p&gt;Redux however, is a lot trickier to explain. Because first, you have
to understand &lt;em&gt;why&lt;/em&gt; you need Redux. And &lt;a href=&#34;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&#34;&gt;you might
not!&lt;/a&gt;
Second, you need to understand the terminology. I mean, reading about
Redux is just a whole slew of &amp;ldquo;actions, reducers, action creators,
store, middleware&amp;rdquo;, blah blah blah. It&amp;rsquo;s pretty overwhelming. And
third there&amp;rsquo;s just so many ways to use Redux. There&amp;rsquo;s
&lt;a href=&#34;https://github.com/erikras/ducks-modular-redux&#34;&gt;ducks&lt;/a&gt;, there&amp;rsquo;s the
&lt;a href=&#34;https://redux.js.org/basics/reducers&#34;&gt;Redux documentation&lt;/a&gt;. It&amp;rsquo;s just
a whole mess of different styles.&lt;/p&gt;
&lt;p&gt;The goal of this post is to explain Redux in a simple, high level
way. I&amp;rsquo;m not going to tell you how to write your reducers, or action
creators or really anything code specific. I just want to give a clear
mental image for the Redux workflow. Let&amp;rsquo;s get started!&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s imagine you&amp;rsquo;re a kid. You get cash, either from an allowance
from your parents, or from odd jobs like mowing lawns or delivering
papers. Because you&amp;rsquo;re a kid, you don&amp;rsquo;t have a bank account, you keep
the cash on you and spend it at places like the grocery store, or the
movie theater. In this case, the cash is the local state. You are the
component. You&amp;rsquo;re not doing anything fancy with it. You&amp;rsquo;re basically
just spending it in a few different places. You get the cash from a
few sources and you spend it in a few places. The cash never leaves
your pocket except for when you decide to spend it. This is perfectly
fine.&lt;/p&gt;
&lt;p&gt;But let&amp;rsquo;s say you grow up and get a job. Your job no longer pays you
in person. They pay you through a bank account. In this model, you
don&amp;rsquo;t actually have the cash on you. Instead, you decide to place the
cash into a separate &lt;em&gt;store&lt;/em&gt; of value. When you need physical cash,
you ask the bank account for some money. When you want to deposit
money, you write a check, which the bank receives, and adjusts your
balance accordingly. By using a check, you have a few benefits. First,
you can easily record the cash flow. You can see your income and your
spending. If there&amp;rsquo;s a discrepancy, you can isolate where and how it
happened. In Redux, these checks are called &lt;em&gt;actions&lt;/em&gt;. Actions are
basically ways of telling the store that you want to change the
state. The bank account is called the &lt;em&gt;store&lt;/em&gt; and keeps the state. The
bank itself is called the &lt;em&gt;reducer&lt;/em&gt; and responds to actions by
adjusting the store accordingly.&lt;/p&gt;
&lt;p&gt;Moving on, there&amp;rsquo;s a few more benefits. For instance, if you have more
than one person using the cash, e.g. a family member, then you don&amp;rsquo;t
have to physically hand that person cash. Instead, you can connect
them to the bank account, and they can withdraw as needed.&lt;/p&gt;
&lt;p&gt;Likewise, there&amp;rsquo;s an idea of middleware. Let&amp;rsquo;s say you want to get
bank alerts on your phone. What you can do is ask the bank to send you
notices whenever someone takes out money. This is called a
&lt;em&gt;middleware&lt;/em&gt;. A middleware intercepts the actions and applies a
function to it, in this case a logging function. However, it doesn&amp;rsquo;t
have to be a logging function. You can ask the bank to take any
deposit and put some of the money away into a savings account. Or even
have the bank send money at a given time. All of these are
accomplishable with middleware.&lt;/p&gt;
&lt;p&gt;I could go on with this metaphor, but honestly it&amp;rsquo;s reaching its
limit. Redux is a great example of simplicity and minimalism in its
design. Redux gives you a way to abstract your state away into a store
and control your state updates with actions and reducers. That&amp;rsquo;s it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rules of Engagement</title>
      <link>https://horriblyunderqualified.com/posts/rules-of-engagement/</link>
      <pubDate>Wed, 21 Feb 2018 17:52:10 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/rules-of-engagement/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve gotten approached by a fair amount of &amp;ldquo;entrepreneurs&amp;rdquo;
recently. Granted this is completely my fault; I put my name up on the
NYU Entreprenurship Lab&amp;rsquo;s wall under developers. And putting all the
jokes and snarky remarks aside, there&amp;rsquo;s a lot of genuine
misunderstanding between these entrepreneurs and developers. I want to
clear some of them up with some &amp;ldquo;rules of engagement&amp;rdquo; for developers.&lt;/p&gt;
&lt;p&gt;So let&amp;rsquo;s say you are the founder of a startup called Breakr, Tinder
for break dancers. You need to find a developer to build your
product. You find a developer&amp;rsquo;s email from a friend/a bathroom
wall/LinkedIn. You decide to send them an email recruiting them to
your startup. Do you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write an extremely vague email out of fear that they&amp;rsquo;ll steal the idea&lt;/li&gt;
&lt;li&gt;Ask them to work for you without any mention of compensation in any form&lt;/li&gt;
&lt;li&gt;Have grammatical and stylistic errors in your writing.&lt;/li&gt;
&lt;li&gt;Ask if they can build an &amp;ldquo;app&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Utter any phrase vaguely similar to &amp;ldquo;I can handle the business side&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&amp;rsquo;re wondering, the answer to all of the above is NO. You should not do any of the
above. I&amp;rsquo;ll outline each in turn:&lt;/p&gt;
&lt;p&gt;First, you need to explain your idea in the email. I know, you watched
The Social Network and immediately became terrified of some &lt;em&gt;nerd&lt;/em&gt;
stealing your idea and becoming a billionaire. First, don&amp;rsquo;t flatter
yourself or your idea. Mark Zuckerberg didn&amp;rsquo;t become a billionaire
because of the idea. Facebook wasn&amp;rsquo;t exactly a groundbreaking idea at
the time. MySpace and Friendster were a thing, and even before that,
someone &lt;em&gt;probably&lt;/em&gt; thought &amp;ldquo;hey, what if, there were like a website
where I could see what my friends are up to.&amp;rdquo; Chances are, your idea
is also not new and is not that valuable. Second, so what? If I took
your idea and made it into a company, it&amp;rsquo;s not like that company is a
guaranteed success.  I still need to, y&amp;rsquo;know, build the product, get
funding, find users, etc. It&amp;rsquo;s not like the moment someone starts
building a similar product it&amp;rsquo;s game over. To paraphrase &lt;a href=&#34;http://www.paulgraham.com/startupideas.html&#34;&gt;Paul
Graham&lt;/a&gt;, competition
isn&amp;rsquo;t the main arbiter of startup success. It&amp;rsquo;s you.&lt;/p&gt;
&lt;p&gt;Second, you need to address the elephant in the room; can you pay me?
And no, just because I&amp;rsquo;m young and &amp;ldquo;horribly underqualified&amp;rdquo; (hehe)
doesn&amp;rsquo;t mean you can assume I&amp;rsquo;ll work for free. At the very least, I&amp;rsquo;d
like a straightforward recognition that no, you cannot pay me. And if
you can&amp;rsquo;t pay me, what can you offer me? Can you offer equity? Are we
partners? Offering a partnership demonstrates humility, which is
at least endearing. If you&amp;rsquo;re expecting free work with no equity,
recognition or even pretend titles, then you&amp;rsquo;re pretty darn
delusional.&lt;/p&gt;
&lt;p&gt;Third, treat this explanation like a pitch towards a potential
investor. Even though I may not be investing money in your company, I
am investing time and effort, which does cost money. This means you
should proofread your emails, use correct spelling and grammatical
sentences. It may seem petty, but an email consisting of &amp;ldquo;i have
idea. can u make it??&amp;rdquo; is a lot less appealing than a well formed,
well thought out proposal. And sure, English may not be your first
language. But there&amp;rsquo;s probably someone you know whose first language
is English. Just send it to them.&lt;/p&gt;
&lt;p&gt;Fourth is the word &amp;ldquo;app&amp;rdquo;. I&amp;rsquo;ve developed a recent aversion to
it. Mainly because the word betrays a lack of research. Asking if I
can build an &amp;ldquo;app&amp;rdquo; is like asking if I make &amp;ldquo;food&amp;rdquo;. It&amp;rsquo;s a little
general. If you&amp;rsquo;re going to propose a product, it&amp;rsquo;d be nice if you did
your homework. Do you want a mobile application or a web application?
Do you want to make a PaaS or a SaaS? After all, aren&amp;rsquo;t entrepreneurs
fast moving, intelligent do-ers who can adapt to many situations?
Seems like you can do some basic research into the different kinds of
software. Even if you resort to buzzwords like .NET or React
or iOS, at least that demonstrates some ability to google terms.&lt;/p&gt;
&lt;p&gt;If your response is &amp;ldquo;well that&amp;rsquo;s your job. You handle the tech.&amp;rdquo; Well,
no. As the founder, you need to have at least a basic grasp on the
tech. Hell, something as simple as &amp;ldquo;I&amp;rsquo;m teaching myself some
JavaScript&amp;rdquo; makes me 100% more interested. It demonstrates that you&amp;rsquo;re
A. humble and B. able to learn new things. A founder that doesn&amp;rsquo;t even
know the high level for the tech is like a ship captain that doesn&amp;rsquo;t
understand how sails work. I don&amp;rsquo;t have a lot of confidence in your
intelligence or your ability to navigate.&lt;/p&gt;
&lt;p&gt;And finally, you need to sell me on yourself. Why are &lt;strong&gt;you&lt;/strong&gt; in
particular worth working alongside? What do you bring to the company?
And don&amp;rsquo;t say &amp;ldquo;business development&amp;rdquo; or &amp;ldquo;the business side&amp;rdquo;. I want
concrete details about what value you provide. Do you have experience
in marketing and raising money? Do you have industry contacts? Are you
like, really good at Excel? Because ultimately, I&amp;rsquo;m investing in you
as much as the company. If I don&amp;rsquo;t think you&amp;rsquo;re worth it, I might just
pull a Zuckerberg and steal your idea.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Speed and Iteration</title>
      <link>https://horriblyunderqualified.com/posts/speed-and-iteration/</link>
      <pubDate>Tue, 20 Feb 2018 14:38:33 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/speed-and-iteration/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve become interested in programming languages recently. This
interest stemmed from Bob Nystrom&amp;rsquo;s wonderful book &lt;a href=&#34;http://www.craftinginterpreters.com/&#34;&gt;Crafting
Interpreters&lt;/a&gt;. Reading the book,
with all the wonderful diagrams and simple code snippets, has given me
the idea of writing my own language. However, what kind of language
should I make? Right now it feels like the programming world is
bursting at the seams with new languages. Golang, Kotlin, Swift, and
Rust have all appeared within the past few years. JavaScript, while
not new, has had a recent explosion of transpilers and extensions,
such as ECMAScript 6 and TypeScript.&lt;/p&gt;
&lt;p&gt;However, I&amp;rsquo;ve noticed one trait that each of these languages have yet
to embrace: speed and iteration. Sure, each language partially
encourages these qualities; Golang is dead easy to learn; Kotlin
interops with Java and has amazing tooling. But they don&amp;rsquo;t make this
the primary focus of the language.&lt;/p&gt;
&lt;p&gt;What do I mean by primary focus? I mean a language with the following
features&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A good REPL&lt;/li&gt;
&lt;li&gt;Easy browser integration&lt;/li&gt;
&lt;li&gt;Package management built in from the beginning&lt;/li&gt;
&lt;li&gt;Good API documentation with examples&lt;/li&gt;
&lt;li&gt;Code scaffolding and boilerplate management&lt;/li&gt;
&lt;li&gt;Good tooling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now granted, these are not easy features. Package management is not a
trivial task. Neither is browser integration. But there&amp;rsquo;s more than a
few good reasons to put in the work.&lt;/p&gt;
&lt;p&gt;First, these features will make your language attractive. And not
attractive in the high level intellectual way that Haskell or OCaml
are &amp;ldquo;interesting&amp;rdquo;, but worth it in the rapid fire, move fast and break
things kind of way. I shouldn&amp;rsquo;t have to compile from source just to
get the language working. I shouldn&amp;rsquo;t have to fumble with awkward
packages that break if you look at them. I shouldn&amp;rsquo;t have to link
system libraries that may or may not exist. It&amp;rsquo;s okay for your
language to be hard to understand. It&amp;rsquo;s not okay for languages to be
hard to write. Part of the reason JavaScript was so damn popular was
that it could be run on literally any internet connected
computer. What I want is a language that literally can be run on a
webpage with a script tag to a CDN. Hell, with the latest progress
with WebAssembly, I wouldn&amp;rsquo;t be surprised to see a language with a
toolchain completely in the browser.&lt;/p&gt;
&lt;p&gt;Second, you want to take advantage of the network effect as much as
possible. Sure, theoretically you could build a bunch of really nice
standard libraries that have every potential (common) function your
users need. But if you make the language easy to write, and make the
package mangement intuitive and robust, you &lt;em&gt;don&amp;rsquo;t need&lt;/em&gt; a standard
library. You just need people writing code who are willing to publish
packages. Okay, sure, that&amp;rsquo;s not easy either. But if you can get a few
insane suckers to start writing code and wrap up their packages,
that&amp;rsquo;s a start. Sure, bug ridden, of questionable quality, incomplete
packages. But that&amp;rsquo;s where the iteration factor takes place. Just as
long as people are writing code in your language, it&amp;rsquo;ll get better.&lt;/p&gt;
&lt;p&gt;I could also claim that your language needs to be easy to understand,
easy to learn. But there is something to be said for sacrificing ease
of use for some benefits. Haskell sacrifices ease of use for purity
and concurrency. Rust sacrifices it for memory safety. How much you
want to go in that direction is up to you. But what shouldn&amp;rsquo;t be up
for debate is that your language should be easy to write.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First Post</title>
      <link>https://horriblyunderqualified.com/posts/first-post/</link>
      <pubDate>Sun, 18 Feb 2018 23:59:43 -0500</pubDate>
      
      <guid>https://horriblyunderqualified.com/posts/first-post/</guid>
      <description>&lt;p&gt;Hi! This is my first post on the new Horribly Underqualified. I
created the original version of this blog last year. However, it
quickly fell out of use, partially because I found a job and partially
because I couldn&amp;rsquo;t be bothered to maintain the Rails app it was built
upon. For this blog I&amp;rsquo;ve decided to take another route. I&amp;rsquo;m using
Hugo, a static site generator. That way I can have a blog with minimal
effort, while also having it look (significantly) nicer than the
previous iteration.&lt;/p&gt;
&lt;p&gt;I might port over some writing from the old blog, but probably not
most of the posts. Hopefully I&amp;rsquo;ll keep this blog relatively up to
date. If not, at least it&amp;rsquo;s low maintenance.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://horriblyunderqualified.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://horriblyunderqualified.com/about/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;This blog is written by me, Nicholas Yang. I am currently a junior at
NYU studying computer science and mathematics. I am interning at
Microsoft for summer 2019. I like to read, program and cook. Some of
my interests include functional programming, compilers and language
design. I&amp;rsquo;m also interested in user interfaces and creating intuitive,
beautiful design.&lt;/p&gt;
&lt;p&gt;The blog name is a tongue in cheek allusion to how many young (and not
young) developers feel while applying for jobs; completely hopelessly,
horribly underqualified. My hope is that I can provide some semblance
of reassurance that no, you are not horribly underqualified. The blog
is built with &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;, a static site
generator. It&amp;rsquo;s hosted on Amazon&amp;rsquo;s S3 service with Cloudfront and
Route 53. The domain was bought with Gandi.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>